substitutions:
  xshut_gpio: GPIO9  # GPIO pin assignment for XSHUT on VL53L1X sensor

external_components:
  - source: github://Averyy/esphome-custom-components
    components: [vl53l1x]
    refresh: 1d

mqtt:
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  username: !secret mqtt_username
  password: !secret mqtt_password
  discovery: true
  discovery_prefix: homeassistant
  birth_message:
    topic: esp32s3-tof/status
    payload: online
  will_message:
    topic: esp32s3-tof/status
    payload: offline
  on_message:
    - topic: esp32s3-tof/control/calibrate
      then:
        - button.press: calibrate_sensor
    - topic: esp32s3-tof/control/restart
      then:
        - switch.turn_on: restart_switch
    - topic: esp32s3-tof/control/set_roi
      then:
        - lambda: |-
            std::string payload = x;
            ESP_LOGD("mqtt", "ROI command received: %s", payload.c_str());

api:
  services:
    - service: set_roi_config
      variables:
        x_spads: int
        y_spads: int
        center: int
      then:
        - lambda: |-
            ESP_LOGD("api", "Setting ROI: X=%d, Y=%d, Center=%d",
                     x_spads, y_spads, center);
            id(roi_x_spads) = x_spads;
            id(roi_y_spads) = y_spads;
            id(roi_center_index) = center;
    - service: advanced_calibration
      variables:
        offset: int
        crosstalk: int
      then:
        - lambda: |-
            ESP_LOGD("api", "Advanced calibration: offset=%d, crosstalk=%d",
                     offset, crosstalk);

i2c:
  - id: bus_a
    sda: ${sda_pin_i2c}
    scl: ${scl_pin_i2c}
    frequency: 400kHz
    scan: true

globals:
  - id: last_distance
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: last_measurement_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: kalman_estimate
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: kalman_error_estimate
    type: float
    restore_value: no
    initial_value: '1.0'

  - id: zone1_threshold
    type: float
    restore_value: yes
    initial_value: '1000.0'
  - id: zone2_threshold
    type: float
    restore_value: yes
    initial_value: '2000.0'
  - id: zone3_threshold
    type: float
    restore_value: yes
    initial_value: '3000.0'

  - id: roi_x_spads
    type: int
    restore_value: yes
    initial_value: '16'
  - id: roi_y_spads
    type: int
    restore_value: yes
    initial_value: '16'
  - id: roi_center_index
    type: int
    restore_value: yes
    initial_value: '199'

  - id: measurement_count
    type: unsigned long
    restore_value: yes
    initial_value: '0'
  - id: error_count
    type: unsigned long
    restore_value: yes
    initial_value: '0'

  # Prefs for distance mode + timing budget (applied after reboot)
  - id: pref_distance_mode
    type: int
    restore_value: yes
    initial_value: '2'   # 0=short,1=medium,2=long
  - id: pref_timing_budget_ms
    type: int
    restore_value: yes
    initial_value: '50'

# Component-level config (defaults); runtime prefs applied next boot
vl53l1x:
  id: tof_sensor
  i2c_id: bus_a
  address: 0x32  # Use your working address
  # address: 0x29
  distance_mode: long
  timing_budget: 50ms
  update_interval: 100ms
  # interrupt_pin: GPIO10
  # roi_x: 16
  # roi_y: 16
  # roi_center: 199

sensor:
  # Consolidated VL53L1X sensors (single driver instance)
  - platform: vl53l1x
    distance:
      id: distance_sensor
      name: "Distance"
      unit_of_measurement: "mm"
      accuracy_decimals: 0
      device_class: distance
      state_class: measurement
      filters:
        - median:
            window_size: 5
            send_every: 1
        - delta: 5.0
        - clamp:
            min_value: 50
            max_value: 4000
            ignore_out_of_range: false
      on_value:
        then:
          - script.execute: calculate_velocity
          - script.execute: update_zone_states
          - script.execute: check_object_detection
          - lambda: |-
              id(measurement_count) += 1;
    # signal_rate:
    #   name: "Signal Rate"
    #   id: signal_rate
    #   unit_of_measurement: "MCPS"
    #   accuracy_decimals: 1
    #   entity_category: diagnostic
    #   icon: "mdi:signal"
    # ambient_rate:
    #   name: "Ambient Rate"
    #   id: ambient_rate
    #   unit_of_measurement: "MCPS"
    #   accuracy_decimals: 1
    #   entity_category: diagnostic
    #   icon: "mdi:brightness-6"
    # range_status:
    #   name: "Range Status"
    #   id: range_status
    #   entity_category: diagnostic
    #   icon: "mdi:check-circle"
    #   on_value:
    #     then:
    #       - lambda: |-
    #           if (x != 0) {
    #             id(error_count) += 1;
    #             ESP_LOGW("sensor", "Range error: %f", x);
    #           }

  - platform: template
    id: velocity_sensor_raw
    name: "Velocity Raw"
    internal: true
    unit_of_measurement: "mm/s"
    accuracy_decimals: 1
    update_interval: never

  - platform: template
    id: velocity_sensor
    name: "Velocity"
    unit_of_measurement: "mm/s"
    accuracy_decimals: 1
    state_class: measurement
    icon: "mdi:speedometer"
    update_interval: never
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1
      - lambda: |-
          if (fabsf(x) < 10.0f) return 0.0f;
          return x;

  - platform: template
    id: acceleration_sensor
    name: "Acceleration"
    unit_of_measurement: "mm/s²"
    accuracy_decimals: 0
    icon: "mdi:axis-arrow"
    update_interval: never

  - platform: template
    name: "Effective SPAD Count"
    id: effective_spad_count
    accuracy_decimals: 0
    entity_category: diagnostic
    icon: "mdi:grid"
    update_interval: 10s
    lambda: |-
      return id(roi_x_spads) * id(roi_y_spads);

  - platform: template
    id: measurement_rate
    name: "Measurement Rate"
    unit_of_measurement: "Hz"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: "mdi:timer"
    update_interval: 5s
    lambda: |-
      static unsigned long last_count = 0;
      static unsigned long last_time = 0;
      unsigned long current_time = millis();
      unsigned long time_diff = current_time - last_time;
      if (time_diff > 0) {
        float rate = (id(measurement_count) - last_count) * 1000.0f / (float)time_diff;
        last_count = id(measurement_count);
        last_time = current_time;
        return rate;
      }
      return 0;

  - platform: template
    id: error_rate
    name: "Error Rate"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: "mdi:alert-circle"
    update_interval: 30s
    lambda: |-
      if (id(measurement_count) > 0) {
        return (id(error_count) * 100.0f) / (float)id(measurement_count);
      }
      return 0;

number:
  - platform: template
    name: "Zone 1 Threshold"
    id: zone1_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 1000
    restore_value: true
    icon: "mdi:numeric-1-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone1_threshold, value: !lambda 'return x;' }
        - lambda: |-
            // Keep ordering: Z1 < Z2 < Z3
            if (x >= id(zone2_threshold)) {
              const float new_z2 = x + 50.0f;
              id(zone2_threshold) = new_z2;
              id(zone2_threshold_number).publish_state(new_z2);
            }

  - platform: template
    name: "Zone 2 Threshold"
    id: zone2_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 2000
    restore_value: true
    icon: "mdi:numeric-2-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone2_threshold, value: !lambda 'return x;' }
        - lambda: |-
            if (x <= id(zone1_threshold)) {
              const float new_z1 = x - 50.0f;
              id(zone1_threshold) = new_z1;
              id(zone1_threshold_number).publish_state(new_z1);
            }
            if (x >= id(zone3_threshold)) {
              const float new_z3 = x + 50.0f;
              id(zone3_threshold) = new_z3;
              id(zone3_threshold_number).publish_state(new_z3);
            }

  - platform: template
    name: "Zone 3 Threshold"
    id: zone3_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 3000
    restore_value: true
    icon: "mdi:numeric-3-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone3_threshold, value: !lambda 'return x;' }
        - lambda: |-
            if (x <= id(zone2_threshold)) {
              const float new_z2 = x - 50.0f;
              id(zone2_threshold) = new_z2;
              id(zone2_threshold_number).publish_state(new_z2);
            }

  # Prefs-backed Timing Budget (ms) — stored & applied on next boot
  - platform: template
    name: "Timing Budget (ms)"
    id: timing_budget_number
    optimistic: true
    min_value: 20
    max_value: 500
    step: 10
    unit_of_measurement: "ms"
    initial_value: 50
    restore_value: true
    icon: "mdi:timer-settings"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: pref_timing_budget_ms, value: !lambda 'return (int)x;' }
        - script.execute: schedule_apply_runtime_prefs

  - platform: template
    name: "Velocity Smoothing"
    id: velocity_smoothing
    optimistic: true
    min_value: 0.01
    max_value: 1.0
    step: 0.01
    initial_value: 0.1
    restore_value: true
    icon: "mdi:blur"
    entity_category: config

binary_sensor:
  - platform: template
    name: "Object Detected"
    id: object_detected
    device_class: occupancy
    icon: "mdi:target"
    lambda: |-
      float dist = id(distance_sensor).state;
      if (!isnan(dist) && dist > 50.0f && dist <= id(zone3_threshold)) return true;
      return false;

  - platform: template
    name: "Zone 1 Detected"
    id: zone1_detected
    device_class: occupancy
    icon: "mdi:numeric-1-circle"
    lambda: |-
      float d = id(distance_sensor).state;
      if (isnan(d) || d <= 0.0f) return false;
      return (d > 50.0f) && (d <= id(zone1_threshold));

  - platform: template
    name: "Zone 2 Detected"
    id: zone2_detected
    device_class: occupancy
    icon: "mdi:numeric-2-circle"
    lambda: |-
      float d = id(distance_sensor).state;
      if (isnan(d) || d <= 0.0f) return false;
      const float z1 = id(zone1_threshold);
      return (d > z1) && (d <= id(zone2_threshold));

  - platform: template
    name: "Zone 3 Detected"
    id: zone3_detected
    device_class: occupancy
    icon: "mdi:numeric-3-circle"
    lambda: |-
      float d = id(distance_sensor).state;
      if (isnan(d) || d <= 0.0f) return false;
      const float z2 = id(zone2_threshold);
      return (d > z2) && (d <= id(zone3_threshold));

  - platform: template
    name: "Moving Towards"
    id: moving_towards
    device_class: moving
    icon: "mdi:arrow-down-bold"
    lambda: |-
      return id(velocity_sensor).has_state() && id(velocity_sensor).state < -50.0f;

  - platform: template
    name: "Moving Away"
    id: moving_away
    device_class: moving
    icon: "mdi:arrow-up-bold"
    lambda: |-
      return id(velocity_sensor).has_state() && id(velocity_sensor).state > 50.0f;

  - platform: template
    name: "Motion Detected"
    id: motion_detected
    device_class: motion
    icon: "mdi:motion-sensor"
    lambda: |-
      return id(velocity_sensor).has_state() && fabsf(id(velocity_sensor).state) > 50.0f;

  # True means PROBLEM (aligned with device_class: problem)
  - platform: template
    name: "Sensor Problem"
    id: sensor_problem
    device_class: problem
    entity_category: diagnostic
    icon: "mdi:alert"
    lambda: |-
      const bool ok = (id(range_status).has_state() && id(range_status).state == 0.0f) &&
                      (id(signal_rate).has_state() && id(signal_rate).state > 0.1f) &&
                      (id(error_rate).has_state() && id(error_rate).state < 10.0f);
      return !ok;

text_sensor:
  - platform: template
    name: "Active Zone"
    id: active_zone
    icon: "mdi:map-marker-radius"
    update_interval: 500ms
    lambda: |-
      if (id(zone1_detected).state) return {"Zone 1 (Close)"};
      else if (id(zone2_detected).state) return {"Zone 2 (Medium)"};
      else if (id(zone3_detected).state) return {"Zone 3 (Far)"};
      else if (id(object_detected).state) return {"Beyond Zone 3"};
      else return {"No Object"};

  - platform: template
    name: "Movement Status"
    id: movement_status
    icon: "mdi:motion"
    update_interval: 500ms
    lambda: |-
      float v = id(velocity_sensor).state;
      if (!id(velocity_sensor).has_state() || fabsf(v) < 10.0f) return {"Stationary"};
      else if (v < -50.0f) return {"Approaching Fast"};
      else if (v < -10.0f) return {"Approaching Slow"};
      else if (v > 50.0f) return {"Receding Fast"};
      else return {"Receding Slow"};

  - platform: template
    name: "Current Distance Mode"
    id: distance_mode_display
    icon: "mdi:ruler"
    entity_category: diagnostic
    lambda: |-
      switch (id(pref_distance_mode)) {
        case 0: return {"short"};
        case 1: return {"medium"};
        default: return {"long"};
      }

  - platform: template
    name: "ROI Configuration"
    id: roi_config_display
    icon: "mdi:grid"
    entity_category: diagnostic
    lambda: |-
      char buffer[50];
      sprintf(buffer, "%dx%d SPADs, Center: %d",
              id(roi_x_spads), id(roi_y_spads), id(roi_center_index));
      return {buffer};

  - platform: template
    name: "System Status"
    id: system_status
    icon: "mdi:information"
    entity_category: diagnostic
    update_interval: 10s
    lambda: |-
      if (id(sensor_problem).state) return {"Sensor Error"};
      else if (id(error_rate).state > 5.0f) return {"Degraded Performance"};
      else return {"Operational"};

select:
  # Prefs-backed mode; we store int 0/1/2 and reboot to apply
  - platform: template
    name: "Distance Mode"
    id: distance_mode_select
    options: ["short", "medium", "long"]
    initial_option: "long"
    optimistic: true
    restore_value: true
    icon: "mdi:tape-measure"
    entity_category: config
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("config", "Distance mode changed to: %s", x.c_str());
            int m = 2;
            if (x == "short") m = 0;
            else if (x == "medium") m = 1;
            id(pref_distance_mode) = m;
        - script.execute: schedule_apply_runtime_prefs

  - platform: template
    name: "ROI Preset"
    id: roi_preset_select
    options: ["Full (16x16)", "Medium (8x8)", "Narrow (4x4)", "Custom"]
    initial_option: "Full (16x16)"
    optimistic: true
    restore_value: true
    icon: "mdi:angle-acute"
    entity_category: config
    on_value:
      then:
        - script.execute: apply_roi_preset

  - platform: template
    name: "Power Mode"
    id: power_mode_select
    options: ["Performance", "Balanced", "Power Save"]
    initial_option: "Balanced"
    optimistic: true
    restore_value: true
    icon: "mdi:battery"
    entity_category: config
    on_value:
      then:
        - script.execute: apply_power_mode

script:
  - id: calculate_velocity
    mode: single
    then:
      - lambda: |-
          float current_distance = id(distance_sensor).state;
          unsigned long current_time = millis();

          if (!isnan(current_distance) && id(last_measurement_time) > 0) {
            unsigned long dt = current_time - id(last_measurement_time);
            if (dt > 50) {
              float dd = current_distance - id(last_distance);
              float raw_v = (dd / (float)dt) * 1000.0f;  // mm/s
              if (fabsf(raw_v) > 5000.0f) raw_v = (raw_v > 0.0f ? 5000.0f : -5000.0f);

              // "Kalman-ish" simple recursive filter
              float error_measurement = 50.0f;
              float k_gain = id(kalman_error_estimate) / (id(kalman_error_estimate) + error_measurement);
              id(kalman_estimate) = id(kalman_estimate) + k_gain * (raw_v - id(kalman_estimate));
              id(kalman_error_estimate) = (1.0f - k_gain) * id(kalman_error_estimate);

              id(velocity_sensor_raw).publish_state(raw_v);
              id(velocity_sensor).publish_state(id(kalman_estimate));

              static float last_v = 0.0f;
              static unsigned long last_v_t = 0;
              if (last_v_t > 0) {
                unsigned long dv_t = current_time - last_v_t;
                if (dv_t > 100) {
                  float a = ((id(kalman_estimate) - last_v) / (float)dv_t) * 1000.0f;
                  id(acceleration_sensor).publish_state(a);
                  last_v = id(kalman_estimate);
                  last_v_t = current_time;
                }
              } else {
                last_v = id(kalman_estimate);
                last_v_t = current_time;
                id(acceleration_sensor).publish_state(0.0f);
              }
            }
          }
          id(last_distance) = current_distance;
          id(last_measurement_time) = current_time;

  - id: update_zone_states
    mode: single
    then:
      - component.update: zone1_detected
      - component.update: zone2_detected
      - component.update: zone3_detected
      - component.update: active_zone

  - id: check_object_detection
    mode: single
    then:
      - component.update: object_detected
      - component.update: movement_status

  - id: check_sensor_status
    mode: single
    then:
      - delay: 2s
      - lambda: |-
          if (id(range_status).has_state() && id(range_status).state != 0.0f) {
            ESP_LOGW("sensor", "VL53L1X sensor status abnormal: %f", id(range_status).state);
          }
          if (id(signal_rate).has_state() && id(signal_rate).state < 0.1f) {
            ESP_LOGW("sensor", "Low signal rate: %f MCPS", id(signal_rate).state);
          }
      - component.update: sensor_problem
      - component.update: system_status

  - id: apply_roi_preset
    mode: single
    then:
      - lambda: |-
          std::string preset = id(roi_preset_select).state;
          ESP_LOGI("config", "Applying ROI preset: %s", preset.c_str());
          if (preset == "Full (16x16)") { id(roi_x_spads) = 16; id(roi_y_spads) = 16; id(roi_center_index) = 199; }
          else if (preset == "Medium (8x8)") { id(roi_x_spads) = 8; id(roi_y_spads) = 8; id(roi_center_index) = 199; }
          else if (preset == "Narrow (4x4)") { id(roi_x_spads) = 4; id(roi_y_spads) = 4; id(roi_center_index) = 199; }
      - component.update: roi_config_display

  - id: apply_power_mode
    mode: single
    then:
      - lambda: |-
          std::string mode = id(power_mode_select).state;
          ESP_LOGI("config", "Applying power mode: %s", mode.c_str());
          if (mode == "Performance") {
            id(tof_sensor).set_update_interval(50);
          } else if (mode == "Balanced") {
            id(tof_sensor).set_update_interval(100);
          } else {
            id(tof_sensor).set_update_interval(250);
          }

  - id: load_saved_settings
    mode: single
    then:
      - logger.log: "Loading saved settings..."
      - number.set: { id: timing_budget_number, value: !lambda 'return (float)id(pref_timing_budget_ms);' }
      - component.update: roi_config_display

  - id: publish_device_info
    mode: single
    then:
      - if:
          condition:
            mqtt.connected:
          then:
            - mqtt.publish:
                topic: "esp32s3-tof/info/device"
                payload: !lambda |-
                  char buffer[256];
                  sprintf(buffer, "{\"name\":\"%s\",\"version\":\"%s\",\"ip\":\"%s\"}",
                          App.get_name().c_str(),
                          ESPHOME_VERSION,
                          WiFi.localIP().toString().c_str());
                  return buffer;
                retain: true

  - id: calibration_sequence
    mode: single
    then:
      - logger.log: "Starting calibration sequence..."
      - lambda: |-
          id(measurement_count) = 0;
          id(error_count) = 0;
          id(last_distance) = 0.0f;
          id(last_measurement_time) = 0;
          id(kalman_estimate) = 0.0f;
          id(kalman_error_estimate) = 1.0f;
      - repeat:
          count: 10
          then:
            - delay: 100ms
      - logger.log: "Calibration complete"

  # Store prefs & reboot device to apply them at next boot
  - id: schedule_apply_runtime_prefs
    mode: restart
    then:
      - logger.log: "Saving preferences… device will reboot in 2 seconds to apply."
      - delay: 2s
      - switch.turn_on: restart_switch

switch:
  - platform: template
    name: "Sensor Enable"
    id: sensor_enable
    optimistic: true
    restore_state: true
    icon: "mdi:power"
    entity_category: config
    turn_on_action:
      - logger.log: "Enabling VL53L1X sensor"
    turn_off_action:
      - logger.log: "Disabling VL53L1X sensor"

  - platform: template
    name: "Auto Calibration"
    id: auto_calibration
    optimistic: true
    restore_state: false
    icon: "mdi:auto-fix"
    entity_category: config

  - platform: template
    name: "Debug Mode"
    id: debug_mode
    optimistic: true
    restore_state: false
    icon: "mdi:bug"
    entity_category: diagnostic
    turn_on_action:
      - logger.log: "Debug mode enabled"
      - logger.set_level: { level: DEBUG }
    turn_off_action:
      - logger.log: "Debug mode disabled"
      - logger.set_level: { level: INFO }

button:
  - platform: template
    name: "Calibrate Sensor"
    id: calibrate_sensor
    entity_category: config
    icon: "mdi:tune"
    on_press:
      - script.execute: calibration_sequence

  - platform: template
    name: "Reset Zone Thresholds"
    entity_category: config
    icon: "mdi:restore"
    on_press:
      - number.set: { id: zone1_threshold_number, value: 1000 }
      - number.set: { id: zone2_threshold_number, value: 2000 }
      - number.set: { id: zone3_threshold_number, value: 3000 }
      - logger.log: "Zone thresholds reset to defaults"

  - platform: template
    name: "Clear Statistics"
    entity_category: diagnostic
    icon: "mdi:delete"
    on_press:
      - lambda: |-
          id(measurement_count) = 0;
          id(error_count) = 0;
          ESP_LOGI("button", "Statistics cleared");

  - platform: template
    name: "Run Diagnostics"
    entity_category: diagnostic
    icon: "mdi:medical-bag"
    on_press:
      - script.execute: run_diagnostics

  - platform: safe_mode
    name: "Safe Mode Boot"
    entity_category: diagnostic
    icon: "mdi:shield"

# light:
#   - platform: status_led
#     name: "Status LED"
#     id: status_led
#     pin:
#       number: ${light_gpio}
#       inverted: true
#     entity_category: config

time:
  - platform: homeassistant
    id: homeassistant_time
    on_time_sync:
      then:
        - logger.log: "Time synchronized with Home Assistant"
  - platform: sntp
    id: sntp_time
    servers: [pool.ntp.org, time.google.com]
    timezone: !secret timezone

interval:
  - interval: 30s
    then:
      - script.execute: check_sensor_status
      - if:
          condition:
            mqtt.connected:
          then:
            - mqtt.publish:
                topic: esp32s3-tof/heartbeat
                payload: !lambda 'return to_string(millis());'

  - interval: 60s
    then:
      - lambda: |-
          ESP_LOGD("stats", "Total measurements: %lu", id(measurement_count));

  - interval: 1h
    then:
      - if:
          condition:
            switch.is_on: auto_calibration
          then:
            - script.execute: calibration_sequence

  - interval: 5min
    then:
      - component.update: free_heap
      - if:
          condition:
            lambda: 'return id(free_heap).state < 20.0f;'
          then:
            - logger.log:
                level: WARN
                format: "Low memory warning: %.1f kB free"
                args: ['id(free_heap).state']
