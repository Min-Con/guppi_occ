##########################################################################################
# ESP32-S3 Super Mini with VL53L1X TOF Sensor
# Production-Ready ESPHome Configuration for Home Assistant
# Version: 2.0 - Full Feature Set
# 
# Features:
# - Object detection with configurable zones
# - Velocity/speed calculation with Kalman filtering
# - Multiple distance modes (short/medium/long)
# - Comprehensive diagnostics and health monitoring
# - ESP-IDF framework with optimizations
# - Network resilience with MQTT backup
# - Advanced ROI configuration support
# - Power management options
# - Enhanced security features
##########################################################################################

substitutions:
  xshut_gpio: GPIO9  # GPIO pin assignment for XSHUT on VL53L1X sensor

# External Components
external_components:
  - source: github://Averyy/esphome-custom-components
    components: [vl53l1x]
    refresh: 1d

# MQTT Configuration (backup communication)
mqtt:
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  username: !secret mqtt_username
  password: !secret mqtt_password
  discovery: true
  discovery_prefix: homeassistant
  birth_message:
    topic: esp32s3-tof/status
    payload: online
  will_message:
    topic: esp32s3-tof/status
    payload: offline
  on_message:
    - topic: esp32s3-tof/control/calibrate
      then:
        - button.press: calibrate_sensor
    - topic: esp32s3-tof/control/restart
      then:
        - button.press: restart_device
    - topic: esp32s3-tof/control/set_roi
      then:
        - lambda: |-
            std::string payload = x;
            ESP_LOGD("mqtt", "ROI command received: %s", payload.c_str());

# # Enable logging with filters
# logger:
#   level: INFO
#   baud_rate: 115200
#   # Reduce noise from components
#   logs:
#     i2c: WARN
#     vl53l1x: DEBUG
#     mqtt: INFO
#     wifi: INFO
#     sensor: DEBUG

# Enable Home Assistant API with encryption
api:
  # encryption:
  #   key: !secret api_encryption_key
  reboot_timeout: 5min
  services:
    # Custom service for ROI adjustment
    - service: set_roi_config
      variables:
        x_spads: int
        y_spads: int
        center: int
      then:
        - lambda: |-
            ESP_LOGD("api", "Setting ROI: X=%d, Y=%d, Center=%d", 
                     x_spads, y_spads, center);
            id(roi_x_spads) = x_spads;
            id(roi_y_spads) = y_spads;
            id(roi_center_index) = center;
            
    # Custom service for advanced calibration
    - service: advanced_calibration
      variables:
        offset: int
        crosstalk: int
      then:
        - lambda: |-
            ESP_LOGD("api", "Advanced calibration: offset=%d, crosstalk=%d", 
                     offset, crosstalk);

# I2C configuration for VL53L1X
i2c:
  sda: ${sda_pin_i2c}
  scl: ${scl_pin_i2c}
  id: bus_a
  scan: true
  frequency: 400khz

# Global Variables for state management
globals:
  # Velocity calculation
  - id: last_distance
    type: float
    restore_value: no
    initial_value: '0.0'
    
  - id: last_measurement_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
    
  # Kalman filter variables
  - id: kalman_estimate
    type: float
    restore_value: no
    initial_value: '0.0'
    
  - id: kalman_error_estimate
    type: float
    restore_value: no
    initial_value: '1.0'
    
  # Zone thresholds
  - id: zone1_threshold
    type: float
    restore_value: yes
    initial_value: '1000.0'
    
  - id: zone2_threshold
    type: float
    restore_value: yes
    initial_value: '2000.0'
    
  - id: zone3_threshold
    type: float
    restore_value: yes
    initial_value: '3000.0'
    
  # ROI configuration
  - id: roi_x_spads
    type: int
    restore_value: yes
    initial_value: '16'
    
  - id: roi_y_spads
    type: int
    restore_value: yes
    initial_value: '16'
    
  - id: roi_center_index
    type: int
    restore_value: yes
    initial_value: '199'
    
  # Performance counters
  - id: measurement_count
    type: unsigned long
    restore_value: yes
    initial_value: '0'
    
  - id: error_count
    type: unsigned long
    restore_value: yes
    initial_value: '0'

# VL53L1X Sensor Configuration
vl53l1x:
  id: tof_sensor
  i2c_id: bus_a
  address: 0x32  # Use your working address
  # address: 0x29
  
  # Distance mode: short (up to 1.3m), medium (up to 3m), long (up to 4m)
  distance_mode: long
  
  # Timing budget in ms (higher = more accurate, 20-500ms)
  timing_budget: 50ms
  
  # Update interval
  update_interval: 100ms
  
  # Enable interrupt pin if connected
  # interrupt_pin: GPIO10
  
  # ROI Configuration (Region of Interest)
  # roi_x: 16  # 4-16 SPADs in X direction
  # roi_y: 16  # 4-16 SPADs in Y direction
  # roi_center: 199  # Center index (default 199 = physical center)

# Sensors
sensor:
  # Main Distance Sensor
  - platform: vl53l1x
    id: distance_sensor
    name: "TOF Distance"
    unit_of_measurement: "mm"
    enable_pin: ${xshut_gpio}  # connected to XSHUT
    i2c_id: bus_a
    address: 0x32  # Use your working address
    distance_mode: MEDIUM
    timing_budget: 200ms
    signal_threshold: 512
    update_interval: 1s
    accuracy_decimals: 2
    device_class: distance
    state_class: measurement
    filters:
      - median:
          window_size: 5
          send_every: 1
      - delta: 5.0  # Only send if changed by 5mm
      - clamp:
          min_value: 50
          max_value: 4000
          ignore_out_of_range: false
    on_value:
      then:
        - script.execute: calculate_velocity
        - script.execute: update_zone_states
        - script.execute: check_object_detection
        - lambda: |-
            id(measurement_count) += 1;

  # - platform: vl53l1x_sensor
  #   name: "VL53L1X Distance Raw"
  #   id: distance_sensor_raw
  #   enable_pin: ${xshut_gpio}  # connected to XSHUT
  #   i2c_id: bus_a
  #   address: 0x32  # Use your working address
  #   distance_mode: MEDIUM
  #   timing_budget: 200ms
  #   signal_threshold: 512
  #   update_interval: 1s
  #   accuracy_decimals: 2
  #   internal: true
    
  #   # ROI configuration matching your working setup
  #   roi_center:
  #     x: 3
  #     y: 8
  #   roi_size:
  #     x: 4
  #     y: 4
    
  #   # Sub-sensors for diagnostics
  #   ambient_rate_sensor:
  #     id: "ambient_rate"
  #     name: "Ambient Rate Raw"
  #     internal: true
    
  #   avg_signal_rate_sensor:
  #     id: "avg_signal_rate"
  #     name: "Average Signal Rate Raw"
  #     internal: true
    
  #   peak_signal_rate_sensor:
  #     id: "peak_signal_rate"
  #     name: "Peak Signal Rate Raw"
  #     internal: true
    
  #   range_status_sensor:
  #     id: "range_status"
  #     name: "Range Status Raw"
  #     internal: true


  # Raw Velocity Sensor (calculated)
  - platform: template
    id: velocity_sensor_raw
    name: "Velocity Raw"
    internal: true
    unit_of_measurement: "mm/s"
    accuracy_decimals: 1
    update_interval: never
    
  # Filtered Velocity Sensor (Kalman filtered)
  - platform: template
    id: velocity_sensor
    name: "Velocity"
    unit_of_measurement: "mm/s"
    accuracy_decimals: 1
    device_class: speed
    state_class: measurement
    icon: "mdi:speedometer"
    update_interval: never
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1
      - lambda: |-
          // Apply threshold to reduce noise
          if (abs(x) < 10) return 0;
          return x;
    
  # Acceleration (derivative of velocity)
  - platform: template
    id: acceleration_sensor
    name: "Acceleration"
    unit_of_measurement: "mm/s²"
    accuracy_decimals: 0
    icon: "mdi:axis-arrow"
    update_interval: never
    
  # Signal Strength (quality indicator)
  - platform: vl53l1x
    signal_rate:
      name: "Signal Rate"
      id: signal_rate
      unit_of_measurement: "MCPS"
      accuracy_decimals: 1
      entity_category: diagnostic
      icon: "mdi:signal"
      
  # Ambient Rate (background light)
  - platform: vl53l1x
    ambient_rate:
      name: "Ambient Rate"
      id: ambient_rate
      unit_of_measurement: "MCPS"
      accuracy_decimals: 1
      entity_category: diagnostic
      icon: "mdi:brightness-6"
      
  # Range Status (0=valid, other values indicate errors)
  - platform: vl53l1x
    range_status:
      name: "Range Status"
      id: range_status
      entity_category: diagnostic
      icon: "mdi:check-circle"
      on_value:
        then:
          - lambda: |-
              if (x != 0) {
                id(error_count) += 1;
                ESP_LOGW("sensor", "Range error: %f", x);
              }
      
  # Effective SPAD count
  - platform: template
    id: effective_spad_count
    name: "Effective SPAD Count"
    accuracy_decimals: 0
    entity_category: diagnostic
    icon: "mdi:grid"
    update_interval: 10s
    lambda: |-
      // Calculate from ROI settings
      return id(roi_x_spads) * id(roi_y_spads);
    
  # Measurement Rate
  - platform: template
    id: measurement_rate
    name: "Measurement Rate"
    unit_of_measurement: "Hz"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: "mdi:timer"
    update_interval: 5s
    lambda: |-
      static unsigned long last_count = 0;
      static unsigned long last_time = 0;
      unsigned long current_time = millis();
      unsigned long time_diff = current_time - last_time;
      if (time_diff > 0) {
        float rate = (id(measurement_count) - last_count) * 1000.0 / time_diff;
        last_count = id(measurement_count);
        last_time = current_time;
        return rate;
      }
      return 0;
    
  # Error Rate
  - platform: template
    id: error_rate
    name: "Error Rate"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: "mdi:alert-circle"
    update_interval: 30s
    lambda: |-
      if (id(measurement_count) > 0) {
        return (id(error_count) * 100.0) / id(measurement_count);
      }
      return 0;
    
  # Device Temperature (internal)
  - platform: internal_temperature
    name: "CPU Temperature"
    entity_category: diagnostic
    icon: "mdi:thermometer"
    
# Number Components for User Configuration
number:
  # Zone Thresholds
  - platform: template
    name: "Zone 1 Threshold"
    id: zone1_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 1000
    restore_value: true
    icon: "mdi:numeric-1-box"
    entity_category: config
    on_value:
      then:
        - globals.set:
            id: zone1_threshold
            value: !lambda 'return x;'
        - logger.log:
            format: "Zone 1 threshold set to %.0f mm"
            args: ['x']
            
  - platform: template
    name: "Zone 2 Threshold"
    id: zone2_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 2000
    restore_value: true
    icon: "mdi:numeric-2-box"
    entity_category: config
    on_value:
      then:
        - globals.set:
            id: zone2_threshold
            value: !lambda 'return x;'
        - logger.log:
            format: "Zone 2 threshold set to %.0f mm"
            args: ['x']
            
  - platform: template
    name: "Zone 3 Threshold"
    id: zone3_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 3000
    restore_value: true
    icon: "mdi:numeric-3-box"
    entity_category: config
    on_value:
      then:
        - globals.set:
            id: zone3_threshold
            value: !lambda 'return x;'
        - logger.log:
            format: "Zone 3 threshold set to %.0f mm"
            args: ['x']
            
  # Timing Budget Configuration
  - platform: template
    name: "Timing Budget"
    id: timing_budget_number
    optimistic: true
    min_value: 20
    max_value: 500
    step: 10
    unit_of_measurement: "ms"
    initial_value: 50
    restore_value: true
    icon: "mdi:timer-settings"
    entity_category: config
    
  # Velocity Smoothing Factor
  - platform: template
    name: "Velocity Smoothing"
    id: velocity_smoothing
    optimistic: true
    min_value: 0.01
    max_value: 1.0
    step: 0.01
    initial_value: 0.1
    restore_value: true
    icon: "mdi:blur"
    entity_category: config

# Binary Sensors
binary_sensor:
  # Main Object Detection
  - platform: template
    name: "Object Detected"
    id: object_detected
    device_class: occupancy
    icon: "mdi:target"
    lambda: |-
      float dist = id(distance_sensor).state;
      // Object detected if distance is valid and less than max range
      if (!isnan(dist) && dist > 50 && dist < 4000) {
        return true;
      }
      return false;
    
  # Zone 1 Detection (closest)
  - platform: template
    name: "Zone 1 Detected"
    id: zone1_detected
    device_class: occupancy
    icon: "mdi:numeric-1-circle"
    lambda: |-
      float dist = id(distance_sensor).state;
      if (!isnan(dist) && dist > 50 && dist <= id(zone1_threshold)) {
        return true;
      }
      return false;
    
  # Zone 2 Detection (middle)
  - platform: template
    name: "Zone 2 Detected"
    id: zone2_detected
    device_class: occupancy
    icon: "mdi:numeric-2-circle"
    lambda: |-
      float dist = id(distance_sensor).state;
      if (!isnan(dist) && dist > id(zone1_threshold) && dist <= id(zone2_threshold)) {
        return true;
      }
      return false;
    
  # Zone 3 Detection (farthest)
  - platform: template
    name: "Zone 3 Detected"
    id: zone3_detected
    device_class: occupancy
    icon: "mdi:numeric-3-circle"
    lambda: |-
      float dist = id(distance_sensor).state;
      if (!isnan(dist) && dist > id(zone2_threshold) && dist <= id(zone3_threshold)) {
        return true;
      }
      return false;
    
  # Movement Direction Indicators
  - platform: template
    name: "Moving Towards"
    id: moving_towards
    device_class: moving
    icon: "mdi:arrow-down-bold"
    
  - platform: template
    name: "Moving Away"
    id: moving_away
    device_class: moving
    icon: "mdi:arrow-up-bold"
    
  # Motion Detection (any movement)
  - platform: template
    name: "Motion Detected"
    id: motion_detected
    device_class: motion
    icon: "mdi:motion-sensor"
    lambda: |-
      float vel = abs(id(velocity_sensor).state);
      return vel > 50;  // Motion if velocity > 50 mm/s
    
  # Sensor Health Status
  - platform: template
    name: "Sensor Healthy"
    id: sensor_healthy
    device_class: problem
    entity_category: diagnostic
    icon: "mdi:check-circle"
    lambda: |-
      // Check if sensor is responding and range status is valid
      return (id(range_status).state == 0) && 
             (id(signal_rate).state > 0.1) &&
             (id(error_rate).state < 10);
    
  # Network Status
  - platform: status
    name: "Connection Status"
    entity_category: diagnostic
    icon: "mdi:network"

# Text Sensors
text_sensor:
  # Zone Status Display
  - platform: template
    name: "Active Zone"
    id: active_zone
    icon: "mdi:map-marker-radius"
    update_interval: 500ms
    lambda: |-
      if (id(zone1_detected).state) {
        return {"Zone 1 (Close)"};
      } else if (id(zone2_detected).state) {
        return {"Zone 2 (Medium)"};
      } else if (id(zone3_detected).state) {
        return {"Zone 3 (Far)"};
      } else if (id(object_detected).state) {
        return {"Beyond Zone 3"};
      } else {
        return {"No Object"};
      }
    
  # Movement Status
  - platform: template
    name: "Movement Status"
    id: movement_status
    icon: "mdi:motion"
    update_interval: 500ms
    lambda: |-
      float vel = id(velocity_sensor).state;
      if (isnan(vel) || abs(vel) < 10) {
        return {"Stationary"};
      } else if (vel < -50) {
        return {"Approaching Fast"};
      } else if (vel < -10) {
        return {"Approaching Slow"};
      } else if (vel > 50) {
        return {"Receding Fast"};
      } else {
        return {"Receding Slow"};
      }
    
  # Distance Mode Display
  - platform: template
    name: "Current Distance Mode"
    id: distance_mode_display
    icon: "mdi:ruler"
    entity_category: diagnostic
    lambda: |-
      return {id(distance_mode_select).state};
    
  # ROI Configuration Display
  - platform: template
    name: "ROI Configuration"
    id: roi_config_display
    icon: "mdi:grid"
    entity_category: diagnostic
    lambda: |-
      char buffer[50];
      sprintf(buffer, "%dx%d SPADs, Center: %d", 
              id(roi_x_spads), id(roi_y_spads), id(roi_center_index));
      return {buffer};
    
  # System Status
  - platform: template
    name: "System Status"
    id: system_status
    icon: "mdi:information"
    entity_category: diagnostic
    update_interval: 10s
    lambda: |-
      if (!id(sensor_healthy).state) {
        return {"Sensor Error"};
      } else if (id(error_rate).state > 5) {
        return {"Degraded Performance"};
      } else {
        return {"Operational"};
      }
    
# Select Components
select:
  # Distance Mode Selection
  - platform: template
    name: "Distance Mode"
    id: distance_mode_select
    options:
      - "short"   # Up to 1.3m, better ambient immunity
      - "medium"  # Up to 3m, balanced
      - "long"    # Up to 4m, maximum range
    initial_option: "long"
    optimistic: true
    restore_value: true
    icon: "mdi:tape-measure"
    entity_category: config
    on_value:
      then:
        - lambda: |-
            ESP_LOGD("config", "Distance mode changed to: %s", x.c_str());
            // Note: Actual mode change requires sensor component modification
        - script.execute: apply_distance_mode
        
  # ROI Preset Selection
  - platform: template
    name: "ROI Preset"
    id: roi_preset_select
    options:
      - "Full (16x16)"    # 27° FOV
      - "Medium (8x8)"    # ~20° FOV
      - "Narrow (4x4)"    # 15° FOV
      - "Custom"
    initial_option: "Full (16x16)"
    optimistic: true
    restore_value: true
    icon: "mdi:angle-acute"
    entity_category: config
    on_value:
      then:
        - script.execute: apply_roi_preset
        
  # Power Mode Selection
  - platform: template
    name: "Power Mode"
    id: power_mode_select
    options:
      - "Performance"  # Maximum update rate
      - "Balanced"     # Normal operation
      - "Power Save"   # Reduced update rate
    initial_option: "Balanced"
    optimistic: true
    restore_value: true
    icon: "mdi:battery"
    entity_category: config
    on_value:
      then:
        - script.execute: apply_power_mode

# Scripts
script:
  # Velocity Calculation with Kalman Filter
  - id: calculate_velocity
    mode: single
    then:
      - lambda: |-
          float current_distance = id(distance_sensor).state;
          unsigned long current_time = millis();
          
          if (!isnan(current_distance) && id(last_measurement_time) > 0) {
            unsigned long time_diff = current_time - id(last_measurement_time);
            
            if (time_diff > 50) {  // Minimum 50ms between calculations
              // Calculate raw velocity
              float distance_diff = current_distance - id(last_distance);
              float raw_velocity = (distance_diff / time_diff) * 1000.0;  // mm/s
              
              // Apply limits
              if (abs(raw_velocity) > 5000) {
                raw_velocity = raw_velocity > 0 ? 5000 : -5000;
              }
              
              // Kalman filter
              float kalman_gain = id(velocity_smoothing).state;
              float error_measurement = 50.0;  // Measurement uncertainty
              
              kalman_gain = id(kalman_error_estimate) / 
                           (id(kalman_error_estimate) + error_measurement);
              id(kalman_estimate) = id(kalman_estimate) + 
                                   kalman_gain * (raw_velocity - id(kalman_estimate));
              id(kalman_error_estimate) = (1 - kalman_gain) * id(kalman_error_estimate);
              
              // Publish filtered velocity
              id(velocity_sensor_raw).publish_state(raw_velocity);
              id(velocity_sensor).publish_state(id(kalman_estimate));
              
              // Calculate acceleration
              static float last_velocity = 0;
              static unsigned long last_vel_time = 0;
              if (last_vel_time > 0) {
                unsigned long vel_time_diff = current_time - last_vel_time;
                if (vel_time_diff > 100) {
                  float acceleration = ((id(kalman_estimate) - last_velocity) / 
                                       vel_time_diff) * 1000.0;
                  id(acceleration_sensor).publish_state(acceleration);
                  last_velocity = id(kalman_estimate);
                  last_vel_time = current_time;
                }
              } else {
                last_velocity = id(kalman_estimate);
                last_vel_time = current_time;
              }
              
              // Update movement direction
              id(moving_towards).publish_state(id(kalman_estimate) < -50);
              id(moving_away).publish_state(id(kalman_estimate) > 50);
              id(motion_detected).publish_state(abs(id(kalman_estimate)) > 50);
            }
          }
          
          id(last_distance) = current_distance;
          id(last_measurement_time) = current_time;
  
  # Update Zone States
  - id: update_zone_states
    mode: single
    then:
      - component.update: zone1_detected
      - component.update: zone2_detected
      - component.update: zone3_detected
      - component.update: active_zone
      
  # Check Object Detection
  - id: check_object_detection
    mode: single
    then:
      - component.update: object_detected
      - component.update: movement_status
      
  # Sensor Status Check
  - id: check_sensor_status
    mode: single
    then:
      - delay: 2s
      - lambda: |-
          if (id(range_status).state != 0) {
            ESP_LOGW("sensor", "VL53L1X sensor status abnormal: %f", id(range_status).state);
          }
          if (id(signal_rate).state < 0.1) {
            ESP_LOGW("sensor", "Low signal rate: %f MCPS", id(signal_rate).state);
          }
      - component.update: sensor_healthy
      - component.update: system_status
      
  # Apply Distance Mode
  - id: apply_distance_mode
    mode: single
    then:
      - lambda: |-
          std::string mode = id(distance_mode_select).state;
          ESP_LOGI("config", "Applying distance mode: %s", mode.c_str());
          
          // Adjust timing budget based on mode
          if (mode == "short") {
            id(timing_budget_number).publish_state(20);
          } else if (mode == "medium") {
            id(timing_budget_number).publish_state(33);
          } else {
            id(timing_budget_number).publish_state(50);
          }
      - component.update: distance_mode_display
      
  # Apply ROI Preset
  - id: apply_roi_preset
    mode: single
    then:
      - lambda: |-
          std::string preset = id(roi_preset_select).state;
          ESP_LOGI("config", "Applying ROI preset: %s", preset.c_str());
          
          if (preset == "Full (16x16)") {
            id(roi_x_spads) = 16;
            id(roi_y_spads) = 16;
            id(roi_center_index) = 199;
          } else if (preset == "Medium (8x8)") {
            id(roi_x_spads) = 8;
            id(roi_y_spads) = 8;
            id(roi_center_index) = 199;
          } else if (preset == "Narrow (4x4)") {
            id(roi_x_spads) = 4;
            id(roi_y_spads) = 4;
            id(roi_center_index) = 199;
          }
          // Custom preset keeps current values
      - component.update: roi_config_display
      
  # Apply Power Mode
  - id: apply_power_mode
    mode: single
    then:
      - lambda: |-
          std::string mode = id(power_mode_select).state;
          ESP_LOGI("config", "Applying power mode: %s", mode.c_str());
          
          if (mode == "Performance") {
            // Maximum update rate
            id(tof_sensor).set_update_interval(50);
          } else if (mode == "Balanced") {
            // Normal operation
            id(tof_sensor).set_update_interval(100);
          } else {  // Power Save
            // Reduced update rate
            id(tof_sensor).set_update_interval(250);
          }
      
  # Load Saved Settings
  - id: load_saved_settings
    mode: single
    then:
      - logger.log: "Loading saved settings..."
      - lambda: |-
          // Apply saved zone thresholds
          id(zone1_threshold_number).publish_state(id(zone1_threshold));
          id(zone2_threshold_number).publish_state(id(zone2_threshold));
          id(zone3_threshold_number).publish_state(id(zone3_threshold));
          
          // Apply saved ROI configuration
          ESP_LOGD("config", "Loaded ROI: %dx%d, Center: %d", 
                   id(roi_x_spads), id(roi_y_spads), id(roi_center_index));
      - component.update: roi_config_display
      
  # Publish Device Information
  - id: publish_device_info
    mode: single
    then:
      - mqtt.publish:
          topic: "esp32s3-tof/info/device"
          payload: !lambda |-
            char buffer[256];
            sprintf(buffer, "{\"name\":\"%s\",\"version\":\"%s\",\"ip\":\"%s\"}",
                    App.get_name().c_str(),
                    ESPHOME_VERSION,
                    WiFi.localIP().toString().c_str());
            return buffer;
          retain: true
      
  # Calibration Sequence
  - id: calibration_sequence
    mode: single
    then:
      - logger.log: "Starting calibration sequence..."
      - light.turn_on:
          id: status_led
          effect: "Calibration"
      - delay: 100ms
      
      # Reset statistics
      - lambda: |-
          id(measurement_count) = 0;
          id(error_count) = 0;
          id(last_distance) = 0;
          id(last_measurement_time) = 0;
          id(kalman_estimate) = 0;
          id(kalman_error_estimate) = 1.0;
      
      # Take calibration measurements
      - repeat:
          count: 10
          then:
            - delay: 100ms
            - component.update: distance_sensor
      
      - logger.log: "Calibration complete"
      - light.turn_off: status_led
      
  # Advanced Diagnostics
  - id: run_diagnostics
    mode: single
    then:
      - logger.log: "Running system diagnostics..."
      - lambda: |-
          ESP_LOGI("diag", "Measurements: %lu, Errors: %lu, Error Rate: %.1f%%",
                   id(measurement_count), id(error_count),
                   (id(error_count) * 100.0) / max((unsigned long)1, id(measurement_count)));
          ESP_LOGI("diag", "Free Heap: %.1f kB, Signal Rate: %.1f MCPS",
                   heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024.0,
                   id(signal_rate).state);
          ESP_LOGI("diag", "ROI Config: %dx%d SPADs, Center: %d",
                   id(roi_x_spads), id(roi_y_spads), id(roi_center_index));

# Switches
switch:
  # Sensor Enable/Disable
  - platform: template
    name: "Sensor Enable"
    id: sensor_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: "mdi:power"
    entity_category: config
    turn_on_action:
      - logger.log: "Enabling VL53L1X sensor"
      - lambda: |-
          // Enable sensor (requires component modification)
          ESP_LOGI("switch", "Sensor enabled");
    turn_off_action:
      - logger.log: "Disabling VL53L1X sensor"
      - lambda: |-
          // Disable sensor (requires component modification)
          ESP_LOGI("switch", "Sensor disabled");
      
  # Auto Calibration
  - platform: template
    name: "Auto Calibration"
    id: auto_calibration
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: "mdi:auto-fix"
    entity_category: config
    
  # Debug Mode
  - platform: template
    name: "Debug Mode"
    id: debug_mode
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: "mdi:bug"
    entity_category: diagnostic
    turn_on_action:
      - logger.log: "Debug mode enabled"
      - logger.set_level:
          level: DEBUG
    turn_off_action:
      - logger.log: "Debug mode disabled"
      - logger.set_level:
          level: INFO
      
# Buttons
button:
  # Calibrate Sensor
  - platform: template
    name: "Calibrate Sensor"
    id: calibrate_sensor
    entity_category: config
    icon: "mdi:tune"
    on_press:
      - script.execute: calibration_sequence
      
  # Reset Zone Thresholds
  - platform: template
    name: "Reset Zone Thresholds"
    entity_category: config
    icon: "mdi:restore"
    on_press:
      - number.set:
          id: zone1_threshold_number
          value: 1000
      - number.set:
          id: zone2_threshold_number
          value: 2000
      - number.set:
          id: zone3_threshold_number
          value: 3000
      - logger.log: "Zone thresholds reset to defaults"
      
  # Clear Statistics
  - platform: template
    name: "Clear Statistics"
    entity_category: diagnostic
    icon: "mdi:delete"
    on_press:
      - lambda: |-
          id(measurement_count) = 0;
          id(error_count) = 0;
          ESP_LOGI("button", "Statistics cleared");
      
  # Run Diagnostics
  - platform: template
    name: "Run Diagnostics"
    entity_category: diagnostic
    icon: "mdi:medical-bag"
    on_press:
      - script.execute: run_diagnostics
      
  # Factory Reset
  - platform: factory_reset
    name: "Factory Reset"
    entity_category: diagnostic
    icon: "mdi:factory"
    disabled_by_default: true
    
  # Safe Mode Boot
  - platform: safe_mode
    name: "Safe Mode Boot"
    entity_category: diagnostic
    icon: "mdi:shield"

# # Status LED with Effects
# light:
#   - platform: status_led
#     name: "Status LED"
#     id: status_led
#     pin:
#       number: GPIO48  # ESP32-S3 Super Mini onboard LED
#       inverted: true
#     entity_category: config
#     effects:
#       # Normal operation effect
#       - strobe:
#           name: "Heartbeat"
#           colors:
#             - state: true
#               duration: 100ms
#             - state: false
#               duration: 900ms
              
#       # Calibration effect
#       - strobe:
#           name: "Calibration"
#           colors:
#             - state: true
#               duration: 250ms
#             - state: false
#               duration: 250ms
              
#       # Error effect
#       - strobe:
#           name: "Error"
#           colors:
#             - state: true
#               duration: 100ms
#             - state: false
#               duration: 100ms
              
  # Optional RGB LED if available (WS2812)
  # - platform: neopixelbus
  #   type: GRB
  #   variant: WS2812
  #   pin: GPIO48
  #   num_leds: 1
  #   name: "RGB Status"
  #   id: rgb_status
  #   effects:
  #     - addressable_rainbow:
  #         name: "Rainbow"
  #         speed: 10
  #         width: 1

# # Time component for timestamps
# time:
#   - platform: homeassistant
#     id: homeassistant_time
#     on_time_sync:
#       then:
#         - logger.log: "Time synchronized with Home Assistant"
  
#   # Fallback to SNTP if Home Assistant unavailable
#   - platform: sntp
#     id: sntp_time
#     servers:
#       - pool.ntp.org
#       - time.google.com
#     timezone: !secret timezone

# Intervals for periodic tasks
interval:
  # Health monitoring
  - interval: 30s
    then:
      - script.execute: check_sensor_status
      - lambda: |-
          // Publish MQTT heartbeat
          if (id(mqtt_client).is_connected()) {
            id(mqtt_client).publish("esp32s3-tof/heartbeat", 
                                   to_string(millis()).c_str());
          }
      
  # Statistics update
  - interval: 60s
    then:
      - lambda: |-
          ESP_LOGD("stats", "Total measurements: %lu", id(measurement_count));
          
  # Auto-calibration check
  - interval: 1h
    then:
      - if:
          condition:
            switch.is_on: auto_calibration
          then:
            - script.execute: calibration_sequence
            
  # Memory monitoring
  - interval: 5min
    then:
      - component.update: free_heap
      - if:
          condition:
            lambda: 'return id(free_heap).state < 20;'
          then:
            - logger.log: 
                level: WARN
                format: "Low memory warning: %.1f kB free"
                args: ['id(free_heap).state']

# Deep Sleep Configuration (optional - for battery operation)
# Uncomment to enable deep sleep mode
# deep_sleep:
#   id: deep_sleep_control
#   run_duration: 30s
#   sleep_duration: 5min
#   wakeup_pin: GPIO0
#   wakeup_pin_mode: INVERT_WAKEUP

# Bluetooth Proxy (optional - for BLE device scanning)
# Uncomment to enable Bluetooth proxy functionality
# bluetooth_proxy:
#   active: false

# Ethernet Configuration (optional - for wired connection)
# Uncomment and configure for Ethernet instead of WiFi
# ethernet:
#   type: LAN8720
#   mdc_pin: GPIO23
#   mdio_pin: GPIO18
#   clk_mode: GPIO17_OUT
#   phy_addr: 0