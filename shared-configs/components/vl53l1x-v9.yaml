##########################################################################################
# ESP32-S3 + VL53L1X (Averyy custom component) — Focused Sensor Configuration
#
# What this file includes:
# - External component (Averyy repo) + minimal MQTT/API hooks you were using
# - I²C bus + VL53L1X sensor block (distance only; diagnostics via templates)
# - Velocity/acceleration derivation, zone logic, health proxy
# - Runtime prefs (distance mode / timing budget) saved + reboot to apply later
# - Missing entities restored (restart_switch, free_heap) so existing automations work
#
# Notes:
# - The Averyy custom component supports the `- platform: vl53l1x` sensor with a `distance:` subkey.
#   It typically does NOT expose `signal_rate:`, `ambient_rate:`, or `range_status:` in YAML.
#   We've removed those to avoid schema errors. The health check now relies on Error Rate % only.
# - `distance_mode:` and `timing_budget:` are LEFT IN PLACE here under the sensor. If validation
#   fails, just comment those two lines. We can add a driver shim later to apply prefs at boot.
##########################################################################################

substitutions:
  # # I²C pins (edit these if your board uses different ones)
  # sda_pin_i2c: GPIO8
  # scl_pin_i2c: GPIO9

  # Optional: XSHUT pin. (Not used in this trimmed config; keep for future use)
  xshut_gpio: GPIO9

external_components:
  - source: github://Averyy/esphome-custom-components
    components: [vl53l1x]
    refresh: 1d

##########################################################################################
# Connectivity hooks used elsewhere in your automations (kept minimal)
##########################################################################################
mqtt:
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  username: !secret mqtt_username
  password: !secret mqtt_password
  discovery: true
  discovery_prefix: homeassistant
  birth_message:
    topic: esp32s3-tof/status
    payload: online
  will_message:
    topic: esp32s3-tof/status
    payload: offline
  on_message:
    # Remote calibration request → runs the calibration script below
    - topic: esp32s3-tof/control/calibrate
      then:
        - button.press: calibrate_sensor
    # Remote restart request → toggles restart switch defined later
    - topic: esp32s3-tof/control/restart
      then:
        - switch.turn_on: restart_switch
    # Placeholder for ROI control payloads (no-op until driver setters are added)
    - topic: esp32s3-tof/control/set_roi
      then:
        - lambda: |-
            std::string payload = x;
            ESP_LOGD("mqtt", "ROI command received: %s", payload.c_str());

api:
  # Minimal custom services you already used (they only set globals for now)
  services:
    - service: set_roi_config
      variables:
        x_spads: int
        y_spads: int
        center: int
      then:
        - lambda: |-
            ESP_LOGD("api", "Setting ROI: X=%d, Y=%d, Center=%d",
                     x_spads, y_spads, center);
            id(roi_x_spads) = x_spads;
            id(roi_y_spads) = y_spads;
            id(roi_center_index) = center;

    - service: advanced_calibration
      variables:
        offset: int
        crosstalk: int
      then:
        - lambda: |-
            ESP_LOGD("api", "Advanced calibration: offset=%d, crosstalk=%d",
                     offset, crosstalk);
            // NOTE: This is a placeholder; actual application requires driver support.

##########################################################################################
# I²C BUS — VL53L1X lives here
##########################################################################################
i2c:
  - id: bus_a
    sda: ${sda_pin_i2c}
    scl: ${scl_pin_i2c}
    frequency: 400kHz
    scan: true

##########################################################################################
# GLOBALS — used by filters, velocity calc, zones, simple health, and runtime prefs
##########################################################################################
globals:
  # Velocity calculation state
  - id: last_distance
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: last_measurement_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  # Simple “Kalman-ish” filter state
  - id: kalman_estimate
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: kalman_error_estimate
    type: float
    restore_value: no
    initial_value: '1.0'

  # Zone thresholds (mm). Zone rules: Z1: 0<d≤Z1, Z2: Z1<d≤Z2, Z3: Z2<d≤Z3
  - id: zone1_threshold
    type: float
    restore_value: yes
    initial_value: '1000.0'
  - id: zone2_threshold
    type: float
    restore_value: yes
    initial_value: '2000.0'
  - id: zone3_threshold
    type: float
    restore_value: yes
    initial_value: '3000.0'

  # ROI globals (not applied to the driver in this trimmed config)
  - id: roi_x_spads
    type: int
    restore_value: yes
    initial_value: '16'
  - id: roi_y_spads
    type: int
    restore_value: yes
    initial_value: '16'
  - id: roi_center_index
    type: int
    restore_value: yes
    initial_value: '199'

  # Counters for basic stats/health proxy
  - id: measurement_count
    type: unsigned long
    restore_value: yes
    initial_value: '0'
  - id: error_count
    type: unsigned long
    restore_value: yes
    initial_value: '0'

  # Runtime prefs (used by UI; applied after reboot when we add a shim)
  - id: pref_distance_mode
    type: int
    restore_value: yes
    initial_value: '2'   # 0=short, 1=medium, 2=long
  - id: pref_timing_budget_ms
    type: int
    restore_value: yes
    initial_value: '50'

##########################################################################################
# VL53L1X CORE COMPONENT — Required for any `sensor.vl53l1x` platform
##########################################################################################
vl53l1x:
  id: tof_sensor
  # i2c_id: bus_a
  address: 0x32           # Your working I²C address (0x29 is the default)
  # distance_mode: long     # comment out if schema error
  # timing_budget: 50ms     # comment out if schema error
  # update_interval: 100ms

##########################################################################################
# VL53L1X SENSOR — Averyy custom component
# IMPORTANT: If validation complains about `distance_mode:` or `timing_budget:`,
#            comment those lines out (driver may not expose them in YAML).
##########################################################################################
sensor:
  - platform: vl53l1x
    # id: tof_sensor
    # i2c_id: bus_a
    # address: 0x32           # Your working I²C address (0x29 is the ST default)
    distance_mode: long     # <-- comment out if schema error
    timing_budget: 50ms     # <-- comment out if schema error
    update_interval: 100ms  # Polling cadence; Power Mode select can change this at runtime

    # Primary distance value (mm). Diagnostics and derived values below depend on this.
    distance:
      id: distance_sensor
      name: "Distance"
      unit_of_measurement: "mm"
      accuracy_decimals: 0
      device_class: distance
      state_class: measurement

      # Filters: median (suppress spikes), only publish ≥5mm change, clamp to plausible range
      filters:
        - median:
            window_size: 5
            send_every: 1
        - delta: 5.0
        - clamp:
            min_value: 50      # ignore extremely short/noise readings
            max_value: 4000    # VL53L1X typical max under good conditions
            ignore_out_of_range: false

      # On each new distance publish:
      on_value:
        then:
          - script.execute: calculate_velocity
          - script.execute: update_zone_states
          - script.execute: check_object_detection
          - lambda: |-
              id(measurement_count) += 1;

  # Derived sensors (no polling; updated from scripts on distance change)
  - platform: template
    id: velocity_sensor_raw
    name: "Velocity Raw"
    internal: true
    unit_of_measurement: "mm/s"
    accuracy_decimals: 1
    update_interval: never

  - platform: template
    id: velocity_sensor
    name: "Velocity"
    unit_of_measurement: "mm/s"
    accuracy_decimals: 1
    state_class: measurement
    icon: "mdi:speedometer"
    update_interval: never
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1
      - lambda: |-
          // Zero out tiny jitter
          if (fabsf(x) < 10.0f) return 0.0f;
          return x;

  - platform: template
    id: acceleration_sensor
    name: "Acceleration"
    unit_of_measurement: "mm/s²"
    accuracy_decimals: 0
    icon: "mdi:axis-arrow"
    update_interval: never

  # Diagnostics (computed locally)
  - platform: template
    name: "Effective SPAD Count"
    id: effective_spad_count
    accuracy_decimals: 0
    entity_category: diagnostic
    icon: "mdi:grid"
    update_interval: 10s
    lambda: |-
      return id(roi_x_spads) * id(roi_y_spads);

  - platform: template
    id: measurement_rate
    name: "Measurement Rate"
    unit_of_measurement: "Hz"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: "mdi:timer"
    update_interval: 5s
    lambda: |-
      static unsigned long last_count = 0;
      static unsigned long last_time = 0;
      unsigned long now = millis();
      unsigned long dt = now - last_time;
      if (dt > 0) {
        float rate = (id(measurement_count) - last_count) * 1000.0f / (float)dt;
        last_count = id(measurement_count);
        last_time = now;
        return rate;
      }
      return 0;

  - platform: template
    id: error_rate
    name: "Error Rate"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: "mdi:alert-circle"
    update_interval: 30s
    lambda: |-
      if (id(measurement_count) > 0) {
        return (id(error_count) * 100.0f) / (float)id(measurement_count);
      }
      return 0;

  # Free heap: used by the 5-min interval block for a low-memory warning
  - platform: template
    id: free_heap
    name: "Free Memory"
    unit_of_measurement: "kB"
    entity_category: diagnostic
    icon: "mdi:memory"
    update_interval: 30s
    lambda: |-
      return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024.0f;

##########################################################################################
# NUMBERS — user-configurable thresholds + timing budget pref (saved, reboot to apply)
##########################################################################################
number:
  # ZONE 1 MAX
  - platform: template
    name: "Zone 1 Threshold"
    id: zone1_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 1000
    restore_value: true
    icon: "mdi:numeric-1-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone1_threshold, value: !lambda 'return x;' }
        - lambda: |-
            // Enforce Z1 < Z2 < Z3 by nudging Z2 if needed
            if (x >= id(zone2_threshold)) {
              const float new_z2 = x + 50.0f;
              id(zone2_threshold) = new_z2;
              id(zone2_threshold_number).publish_state(new_z2);
            }

  # ZONE 2 MAX
  - platform: template
    name: "Zone 2 Threshold"
    id: zone2_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 2000
    restore_value: true
    icon: "mdi:numeric-2-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone2_threshold, value: !lambda 'return x;' }
        - lambda: |-
            // Keep Z1 < Z2 < Z3 by adjusting neighbors if necessary
            if (x <= id(zone1_threshold)) {
              const float new_z1 = x - 50.0f;
              id(zone1_threshold) = new_z1;
              id(zone1_threshold_number).publish_state(new_z1);
            }
            if (x >= id(zone3_threshold)) {
              const float new_z3 = x + 50.0f;
              id(zone3_threshold) = new_z3;
              id(zone3_threshold_number).publish_state(new_z3);
            }

  # ZONE 3 MAX
  - platform: template
    name: "Zone 3 Threshold"
    id: zone3_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 3000
    restore_value: true
    icon: "mdi:numeric-3-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone3_threshold, value: !lambda 'return x;' }
        - lambda: |-
            // Ensure Z2 < Z3 by nudging Z2 down if user set Z3 too low
            if (x <= id(zone2_threshold)) {
              const float new_z2 = x - 50.0f;
              id(zone2_threshold) = new_z2;
              id(zone2_threshold_number).publish_state(new_z2);
            }

  # TIMING BUDGET (preference only in this build; applied after reboot when shim is added)
  - platform: template
    name: "Timing Budget (ms)"
    id: timing_budget_number
    optimistic: true
    min_value: 20
    max_value: 500
    step: 10
    unit_of_measurement: "ms"
    initial_value: 50
    restore_value: true
    icon: "mdi:timer-settings"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: pref_timing_budget_ms, value: !lambda 'return (int)x;' }
        - script.execute: schedule_apply_runtime_prefs  # Reboots device to apply later

##########################################################################################
# BINARY SENSORS — object + zones + movement + simple health
##########################################################################################
binary_sensor:
  - platform: template
    name: "Object Detected"
    id: object_detected
    device_class: occupancy
    icon: "mdi:target"
    lambda: |-
      float d = id(distance_sensor).state;
      return (!isnan(d) && d > 50.0f && d <= id(zone3_threshold));

  - platform: template
    name: "Zone 1 Detected"
    id: zone1_detected
    device_class: occupancy
    icon: "mdi:numeric-1-circle"
    lambda: |-
      float d = id(distance_sensor).state;
      if (isnan(d) || d <= 0.0f) return false;
      return (d > 50.0f) && (d <= id(zone1_threshold));

  - platform: template
    name: "Zone 2 Detected"
    id: zone2_detected
    device_class: occupancy
    icon: "mdi:numeric-2-circle"
    lambda: |-
      float d = id(distance_sensor).state;
      if (isnan(d) || d <= 0.0f) return false;
      const float z1 = id(zone1_threshold);
      return (d > z1) && (d <= id(zone2_threshold));

  - platform: template
    name: "Zone 3 Detected"
    id: zone3_detected
    device_class: occupancy
    icon: "mdi:numeric-3-circle"
    lambda: |-
      float d = id(distance_sensor).state;
      if (isnan(d) || d <= 0.0f) return false;
      const float z2 = id(zone2_threshold);
      return (d > z2) && (d <= id(zone3_threshold));

  - platform: template
    name: "Moving Towards"
    id: moving_towards
    device_class: moving
    icon: "mdi:arrow-down-bold"
    lambda: |-
      return id(velocity_sensor).has_state() && id(velocity_sensor).state < -50.0f;

  - platform: template
    name: "Moving Away"
    id: moving_away
    device_class: moving
    icon: "mdi:arrow-up-bold"
    lambda: |-
      return id(velocity_sensor).has_state() && id(velocity_sensor).state > 50.0f;

  - platform: template
    name: "Motion Detected"
    id: motion_detected
    device_class: motion
    icon: "mdi:motion-sensor"
    lambda: |-
      return id(velocity_sensor).has_state() && fabsf(id(velocity_sensor).state) > 50.0f;

  # Health proxy: with the custom driver not exposing range_status/signal_rate in YAML,
  # we flag a problem when Error Rate ≥ 10% (tune threshold as needed).
  - platform: template
    name: "Sensor Problem"
    id: sensor_problem
    device_class: problem
    entity_category: diagnostic
    icon: "mdi:alert"
    lambda: |-
      if (id(error_rate).has_state() && id(error_rate).state >= 10.0f) return true;
      return false;

##########################################################################################
# TEXT SENSORS — UX helpers
##########################################################################################
text_sensor:
  - platform: template
    name: "Active Zone"
    id: active_zone
    icon: "mdi:map-marker-radius"
    update_interval: 500ms
    lambda: |-
      if (id(zone1_detected).state) return {"Zone 1 (Close)"};
      else if (id(zone2_detected).state) return {"Zone 2 (Medium)"};
      else if (id(zone3_detected).state) return {"Zone 3 (Far)"};
      else if (id(object_detected).state) return {"Beyond Zone 3"};
      else return {"No Object"};

  - platform: template
    name: "Movement Status"
    id: movement_status
    icon: "mdi:motion"
    update_interval: 500ms
    lambda: |-
      if (!id(velocity_sensor).has_state()) return {"Stationary"};
      float v = id(velocity_sensor).state;
      if (fabsf(v) < 10.0f) return {"Stationary"};
      else if (v < -50.0f) return {"Approaching Fast"};
      else if (v < -10.0f) return {"Approaching Slow"};
      else if (v > 50.0f) return {"Receding Fast"};
      else return {"Receding Slow"};

  - platform: template
    name: "Current Distance Mode"
    id: distance_mode_display
    icon: "mdi:ruler"
    entity_category: diagnostic
    lambda: |-
      switch (id(pref_distance_mode)) {
        case 0: return {"short"};
        case 1: return {"medium"};
        default: return {"long"};
      }

  - platform: template
    name: "ROI Configuration"
    id: roi_config_display
    icon: "mdi:grid"
    entity_category: diagnostic
    lambda: |-
      char buf[50];
      sprintf(buf, "%dx%d SPADs, Center: %d",
              id(roi_x_spads), id(roi_y_spads), id(roi_center_index));
      return {buf};

  - platform: template
    name: "System Status"
    id: system_status
    icon: "mdi:information"
    entity_category: diagnostic
    update_interval: 10s
    lambda: |-
      if (id(sensor_problem).state) return {"Sensor Error"};
      else if (id(error_rate).state > 5.0f) return {"Degraded Performance"};
      else return {"Operational"};

##########################################################################################
# SELECTS — prefs (distance mode/power) that trigger apply+reboot script
##########################################################################################
select:
  - platform: template
    name: "Distance Mode"
    id: distance_mode_select
    options: ["short", "medium", "long"]
    initial_option: "long"
    optimistic: true
    restore_value: true
    icon: "mdi:tape-measure"
    entity_category: config
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("config", "Distance mode changed to: %s", x.c_str());
            int m = 2;  // long
            if (x == "short") m = 0;
            else if (x == "medium") m = 1;
            id(pref_distance_mode) = m;
        - script.execute: schedule_apply_runtime_prefs

  - platform: template
    name: "Power Mode"
    id: power_mode_select
    options: ["Performance", "Balanced", "Power Save"]
    initial_option: "Balanced"
    optimistic: true
    restore_value: true
    icon: "mdi:battery"
    entity_category: config
    on_value:
      then:
        - script.execute: apply_power_mode

##########################################################################################
# SCRIPTS — velocity math, zone refresh, health check, reboot-after-pref-change
##########################################################################################
script:
  - id: calculate_velocity
    mode: single
    then:
      - lambda: |-
          float d = id(distance_sensor).state;
          unsigned long now = millis();

          if (!isnan(d) && id(last_measurement_time) > 0) {
            unsigned long dt = now - id(last_measurement_time);
            if (dt > 50) {
              float dd = d - id(last_distance);
              float raw_v = (dd / (float)dt) * 1000.0f;  // mm/s
              if (fabsf(raw_v) > 5000.0f) raw_v = (raw_v > 0.0f ? 5000.0f : -5000.0f);

              // Simple recursive filter (not a full Kalman)
              float meas_err = 50.0f;
              float k = id(kalman_error_estimate) / (id(kalman_error_estimate) + meas_err);
              id(kalman_estimate) = id(kalman_estimate) + k * (raw_v - id(kalman_estimate));
              id(kalman_error_estimate) = (1.0f - k) * id(kalman_error_estimate);

              id(velocity_sensor_raw).publish_state(raw_v);
              id(velocity_sensor).publish_state(id(kalman_estimate));

              static float last_v = 0.0f;
              static unsigned long last_v_t = 0;
              if (last_v_t > 0) {
                unsigned long dv_t = now - last_v_t;
                if (dv_t > 100) {
                  float a = ((id(kalman_estimate) - last_v) / (float)dv_t) * 1000.0f;
                  id(acceleration_sensor).publish_state(a);
                  last_v = id(kalman_estimate);
                  last_v_t = now;
                }
              } else {
                last_v = id(kalman_estimate);
                last_v_t = now;
                id(acceleration_sensor).publish_state(0.0f);
              }
            }
          }
          id(last_distance) = d;
          id(last_measurement_time) = now;

  - id: update_zone_states
    mode: single
    then:
      - component.update: zone1_detected
      - component.update: zone2_detected
      - component.update: zone3_detected
      - component.update: active_zone

  - id: check_object_detection
    mode: single
    then:
      - component.update: object_detected
      - component.update: movement_status

  - id: apply_power_mode
    mode: single
    then:
      - lambda: |-
          std::string mode = id(power_mode_select).state;
          ESP_LOGI("config", "Applying power mode: %s", mode.c_str());
          if (mode == "Performance") {
            id(tof_sensor).set_update_interval(50);
          } else if (mode == "Balanced") {
            id(tof_sensor).set_update_interval(100);
          } else {
            id(tof_sensor).set_update_interval(250);
          }

  - id: schedule_apply_runtime_prefs
    mode: restart
    then:
      - logger.log: "Saving preferences… device will reboot in 2 seconds to apply."
      - delay: 2s
      - switch.turn_on: restart_switch

##########################################################################################
# CONTROL SURFACES — restart switch + test/maintenance buttons
##########################################################################################
switch:
  # Used by MQTT restart and by schedule_apply_runtime_prefs
  - platform: restart
    id: restart_switch
    name: "Restart Device"
    entity_category: diagnostic

  # Optional: gate “sensor enabled/disabled” in your UI (no driver hook here)
  - platform: template
    name: "Sensor Enable"
    id: sensor_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: "mdi:power"
    entity_category: config
    turn_on_action:
      - logger.log: "Sensor enable (placeholder — add driver hook if needed)"
    turn_off_action:
      - logger.log: "Sensor disable (placeholder — add driver hook if needed)"

button:
  - platform: template
    name: "Calibrate Sensor"
    id: calibrate_sensor
    entity_category: config
    icon: "mdi:tune"
    on_press:
      - logger.log: "Calibration sequence: reset counters & take a few samples"
      - lambda: |-
          id(measurement_count) = 0;
          id(error_count) = 0;
          id(last_distance) = 0.0f;
          id(last_measurement_time) = 0;
          id(kalman_estimate) = 0.0f;
          id(kalman_error_estimate) = 1.0f;
      - repeat:
          count: 10
          then:
            - delay: 100ms

  - platform: template
    name: "Reset Zone Thresholds"
    entity_category: config
    icon: "mdi:restore"
    on_press:
      - number.set: { id: zone1_threshold_number, value: 1000 }
      - number.set: { id: zone2_threshold_number, value: 2000 }
      - number.set: { id: zone3_threshold_number, value: 3000 }
      - logger.log: "Zone thresholds reset to defaults"

  - platform: template
    name: "Clear Statistics"
    entity_category: diagnostic
    icon: "mdi:delete"
    on_press:
      - lambda: |-
          id(measurement_count) = 0;
          id(error_count) = 0;
          ESP_LOGI("button", "Statistics cleared");

##########################################################################################
# TIME + PERIODIC TASKS — time sync and simple heartbeats/warnings
##########################################################################################
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time_sync:
      then:
        - logger.log: "Time synchronized with Home Assistant"

  - platform: sntp
    id: sntp_time
    servers: [pool.ntp.org, time.google.com]
    timezone: !secret timezone   # e.g., America/New_York

interval:
  # Health check proxy + MQTT heartbeat
  - interval: 30s
    then:
      - if:
          condition:
            mqtt.connected:
          then:
            - mqtt.publish:
                topic: esp32s3-tof/heartbeat
                payload: !lambda 'return to_string(millis());'

  # Stats trace
  - interval: 60s
    then:
      - lambda: |-
          ESP_LOGD("stats", "Total measurements: %lu", id(measurement_count));

  # Low memory warning (uses free_heap sensor defined above)
  - interval: 5min
    then:
      - component.update: free_heap
      - if:
          condition:
            lambda: 'return id(free_heap).state < 20.0f;'
          then:
            - logger.log:
                level: WARN
                format: "Low memory warning: %.1f kB free"
                args: ['id(free_heap).state']
