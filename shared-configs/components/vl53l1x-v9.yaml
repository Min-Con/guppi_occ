##########################################################################################
# ESP32-S3 + VL53L1X (Averyy custom component) — Focused Sensor Configuration (Option B)
#
# Highlights in this version:
# - Template binary/text sensors are *driven* via publish_state() in distance.on_value
#   (no polling, no component.update calls on non-polling components).
# - Top-level vl53l1x component holds bus/address/update_interval; sensor platform only
#   defines the distance reading.
##########################################################################################

substitutions:
  # I²C pins (edit these if your board uses different ones)
  # sda_pin_i2c: GPIO8
  # scl_pin_i2c: GPIO9

  # Optional: XSHUT pin (not used here, reserved for future)
  xshut_gpio: GPIO9

external_components:
  - source: github://Averyy/esphome-custom-components
    components: [vl53l1x]
    refresh: 1d

##########################################################################################
# Connectivity hooks (minimal)
##########################################################################################
mqtt:
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  username: !secret mqtt_username
  password: !secret mqtt_password
  discovery: true
  discovery_prefix: homeassistant
  birth_message: { topic: esp32s3-tof/status, payload: online }
  will_message:  { topic: esp32s3-tof/status, payload: offline }
  on_message:
    - topic: esp32s3-tof/control/calibrate
      then: { - button.press: calibrate_sensor }
    - topic: esp32s3-tof/control/restart
      then: { - switch.turn_on: restart_switch }
    - topic: esp32s3-tof/control/set_roi
      then:
        - lambda: |-
            ESP_LOGD("mqtt", "ROI command received: %s", x.c_str());

api:
  services:
    - service: set_roi_config
      variables: { x_spads: int, y_spads: int, center: int }
      then:
        - lambda: |-
            ESP_LOGD("api", "Setting ROI: X=%d, Y=%d, Center=%d", x_spads, y_spads, center);
            id(roi_x_spads) = x_spads;
            id(roi_y_spads) = y_spads;
            id(roi_center_index) = center;

    - service: advanced_calibration
      variables: { offset: int, crosstalk: int }
      then:
        - lambda: |-
            ESP_LOGD("api", "Advanced calibration: offset=%d, crosstalk=%d", offset, crosstalk);
            // Placeholder: requires driver support to take effect.

##########################################################################################
# I²C BUS
##########################################################################################
i2c:
  - id: bus_a
    sda: ${sda_pin_i2c}
    scl: ${scl_pin_i2c}
    frequency: 400kHz
    scan: true

##########################################################################################
# GLOBALS
##########################################################################################
globals:
  # Velocity calc state
  - { id: last_distance,           type: float,          restore_value: no,  initial_value: '0.0' }
  - { id: last_measurement_time,   type: unsigned long,  restore_value: no,  initial_value: '0'   }

  # Simple recursive filter state
  - { id: kalman_estimate,         type: float,          restore_value: no,  initial_value: '0.0' }
  - { id: kalman_error_estimate,   type: float,          restore_value: no,  initial_value: '1.0' }

  # Zone thresholds (mm)
  - { id: zone1_threshold, type: float, restore_value: yes, initial_value: '1000.0' }
  - { id: zone2_threshold, type: float, restore_value: yes, initial_value: '2000.0' }
  - { id: zone3_threshold, type: float, restore_value: yes, initial_value: '3000.0' }

  # ROI info (not applied to driver in this build)
  - { id: roi_x_spads,      type: int, restore_value: yes, initial_value: '16'  }
  - { id: roi_y_spads,      type: int, restore_value: yes, initial_value: '16'  }
  - { id: roi_center_index, type: int, restore_value: yes, initial_value: '199' }

  # Counters
  - { id: measurement_count, type: unsigned long, restore_value: yes, initial_value: '0' }
  - { id: error_count,       type: unsigned long, restore_value: yes, initial_value: '0' }

  # Runtime prefs (applied post-reboot when we add the shim)
  - { id: pref_distance_mode,     type: int, restore_value: yes, initial_value: '2' }   # 0/1/2
  - { id: pref_timing_budget_ms,  type: int, restore_value: yes, initial_value: '50' }

##########################################################################################
# VL53L1X CORE COMPONENT (required by the platform sensor)
##########################################################################################
vl53l1x:
  id: tof_sensor
  i2c_id: bus_a
  address: 0x32           # Use 0x29 if that's your module's default
  update_interval: 100ms  # Power Mode script tweaks this at runtime
  # distance_mode: long    # If schema errors here, comment out (driver may not expose)
  # timing_budget: 50ms    # If schema errors here, comment out

##########################################################################################
# SENSORS
##########################################################################################
sensor:
  # Distance from the VL53L1X. All derived logic fires from its on_value handler.
  - platform: vl53l1x
    distance:
      id: distance_sensor
      name: "Distance"
      unit_of_measurement: "mm"
      accuracy_decimals: 0
      device_class: distance
      state_class: measurement
      filters:
        - median: { window_size: 5, send_every: 1 }
        - delta: 5.0
        - clamp:
            min_value: 50
            max_value: 4000
            ignore_out_of_range: false
      on_value:
        then:
          # 1) Update velocity + acceleration first (Velocity template publishes inside script)
          - script.execute: calculate_velocity

          # 2) Compute zones/object + publish to template binary sensors
          - lambda: |-
              const float d = id(distance_sensor).state;
              const bool valid = (!isnan(d) && d > 50.0f);
              const float z1 = id(zone1_threshold);
              const float z2 = id(zone2_threshold);
              const float z3 = id(zone3_threshold);

              const bool obj = valid && (d <= z3);
              const bool in_z1 = valid && (d <= z1);
              const bool in_z2 = valid && (d > z1 && d <= z2);
              const bool in_z3 = valid && (d > z2 && d <= z3);

              id(object_detected).publish_state(obj);
              id(zone1_detected).publish_state(in_z1);
              id(zone2_detected).publish_state(in_z2);
              id(zone3_detected).publish_state(in_z3);

              // Movement flags from current velocity (already updated by calculate_velocity)
              if (id(velocity_sensor).has_state()) {
                const float v = id(velocity_sensor).state;
                id(moving_towards).publish_state(v < -50.0f);
                id(moving_away).publish_state(v > 50.0f);
                id(motion_detected).publish_state(fabsf(v) > 50.0f);
              }

              // Active Zone text
              if (in_z1)      id(active_zone).publish_state("Zone 1 (Close)");
              else if (in_z2) id(active_zone).publish_state("Zone 2 (Medium)");
              else if (in_z3) id(active_zone).publish_state("Zone 3 (Far)");
              else if (obj)   id(active_zone).publish_state("Beyond Zone 3");
              else            id(active_zone).publish_state("No Object");

              id(measurement_count) += 1;

  # Derived (no polling; values are pushed by scripts)
  - platform: template
    id: velocity_sensor_raw
    name: "Velocity Raw"
    internal: true
    unit_of_measurement: "mm/s"
    accuracy_decimals: 1
    update_interval: never

  - platform: template
    id: velocity_sensor
    name: "Velocity"
    unit_of_measurement: "mm/s"
    accuracy_decimals: 1
    state_class: measurement
    icon: "mdi:speedometer"
    update_interval: never
    filters:
      - sliding_window_moving_average: { window_size: 5, send_every: 1 }
      - lambda: |-
          if (fabsf(x) < 10.0f) return 0.0f;  // squash jitter
          return x;

  - platform: template
    id: acceleration_sensor
    name: "Acceleration"
    unit_of_measurement: "mm/s²"
    accuracy_decimals: 0
    icon: "mdi:axis-arrow"
    update_interval: never

  # Diagnostics (computed locally)
  - platform: template
    name: "Effective SPAD Count"
    id: effective_spad_count
    accuracy_decimals: 0
    entity_category: diagnostic
    icon: "mdi:grid"
    update_interval: 10s
    lambda: |-
      return id(roi_x_spads) * id(roi_y_spads);

  - platform: template
    id: measurement_rate
    name: "Measurement Rate"
    unit_of_measurement: "Hz"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: "mdi:timer"
    update_interval: 5s
    lambda: |-
      static unsigned long last_count = 0, last_time = 0;
      const unsigned long now = millis();
      const unsigned long dt = now - last_time;
      if (dt > 0) {
        const float rate = (id(measurement_count) - last_count) * 1000.0f / (float)dt;
        last_count = id(measurement_count);
        last_time = now;
        return rate;
      }
      return 0;

  - platform: template
    id: error_rate
    name: "Error Rate"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: "mdi:alert-circle"
    update_interval: 30s
    lambda: |-
      if (id(measurement_count) > 0) {
        return (id(error_count) * 100.0f) / (float)id(measurement_count);
      }
      return 0;

  - platform: template
    id: free_heap
    name: "Free Memory"
    unit_of_measurement: "kB"
    entity_category: diagnostic
    icon: "mdi:memory"
    update_interval: 30s
    lambda: |-
      return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024.0f;

##########################################################################################
# NUMBERS — thresholds + timing budget preference
##########################################################################################
number:
  - platform: template
    name: "Zone 1 Threshold"
    id: zone1_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 1000
    restore_value: true
    icon: "mdi:numeric-1-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone1_threshold, value: !lambda 'return x;' }
        - lambda: |-
            if (x >= id(zone2_threshold)) {
              const float new_z2 = x + 50.0f;
              id(zone2_threshold) = new_z2;
              id(zone2_threshold_number).publish_state(new_z2);
            }

  - platform: template
    name: "Zone 2 Threshold"
    id: zone2_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 2000
    restore_value: true
    icon: "mdi:numeric-2-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone2_threshold, value: !lambda 'return x;' }
        - lambda: |-
            if (x <= id(zone1_threshold)) {
              const float new_z1 = x - 50.0f;
              id(zone1_threshold) = new_z1;
              id(zone1_threshold_number).publish_state(new_z1);
            }
            if (x >= id(zone3_threshold)) {
              const float new_z3 = x + 50.0f;
              id(zone3_threshold) = new_z3;
              id(zone3_threshold_number).publish_state(new_z3);
            }

  - platform: template
    name: "Zone 3 Threshold"
    id: zone3_threshold_number
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 3000
    restore_value: true
    icon: "mdi:numeric-3-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone3_threshold, value: !lambda 'return x;' }
        - lambda: |-
            if (x <= id(zone2_threshold)) {
              const float new_z2 = x - 50.0f;
              id(zone2_threshold) = new_z2;
              id(zone2_threshold_number).publish_state(new_z2);
            }

  - platform: template
    name: "Timing Budget (ms)"
    id: timing_budget_number
    optimistic: true
    min_value: 20
    max_value: 500
    step: 10
    unit_of_measurement: "ms"
    initial_value: 50
    restore_value: true
    icon: "mdi:timer-settings"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: pref_timing_budget_ms, value: !lambda 'return (int)x;' }
        - script.execute: schedule_apply_runtime_prefs

##########################################################################################
# BINARY SENSORS — states are pushed (no lambdas needed)
##########################################################################################
binary_sensor:
  - platform: template
    id: object_detected
    name: "Object Detected"
    device_class: occupancy
    icon: "mdi:target"

  - platform: template
    id: zone1_detected
    name: "Zone 1 Detected"
    device_class: occupancy
    icon: "mdi:numeric-1-circle"

  - platform: template
    id: zone2_detected
    name: "Zone 2 Detected"
    device_class: occupancy
    icon: "mdi:numeric-2-circle"

  - platform: template
    id: zone3_detected
    name: "Zone 3 Detected"
    device_class: occupancy
    icon: "mdi:numeric-3-circle"

  - platform: template
    id: moving_towards
    name: "Moving Towards"
    device_class: moving
    icon: "mdi:arrow-down-bold"

  - platform: template
    id: moving_away
    name: "Moving Away"
    device_class: moving
    icon: "mdi:arrow-up-bold"

  - platform: template
    id: motion_detected
    name: "Motion Detected"
    device_class: motion
    icon: "mdi:motion-sensor"

  # Health proxy: raise problem if Error Rate ≥ 10%
  - platform: template
    id: sensor_problem
    name: "Sensor Problem"
    device_class: problem
    entity_category: diagnostic
    icon: "mdi:alert"
    lambda: |-
      if (id(error_rate).has_state() && id(error_rate).state >= 10.0f) return true;
      return false;

##########################################################################################
# TEXT SENSORS — states are pushed (no lambdas needed)
##########################################################################################
text_sensor:
  - platform: template
    id: active_zone
    name: "Active Zone"
    icon: "mdi:map-marker-radius"

  - platform: template
    id: movement_status
    name: "Movement Status"
    icon: "mdi:motion"

  - platform: template
    id: distance_mode_display
    name: "Current Distance Mode"
    icon: "mdi:ruler"
    entity_category: diagnostic
    lambda: |-
      switch (id(pref_distance_mode)) {
        case 0: return {"short"};
        case 1: return {"medium"};
        default: return {"long"};
      }

  - platform: template
    id: roi_config_display
    name: "ROI Configuration"
    icon: "mdi:grid"
    entity_category: diagnostic
    lambda: |-
      char buf[50];
      sprintf(buf, "%dx%d SPADs, Center: %d", id(roi_x_spads), id(roi_y_spads), id(roi_center_index));
      return {buf};

  - platform: template
    id: system_status
    name: "System Status"
    icon: "mdi:information"
    entity_category: diagnostic
    update_interval: 10s
    lambda: |-
      if (id(sensor_problem).state) return {"Sensor Error"};
      else if (id(error_rate).state > 5.0f) return {"Degraded Performance"};
      else return {"Operational"};

##########################################################################################
# SELECTS — prefs (distance mode/power)
##########################################################################################
select:
  - platform: template
    id: distance_mode_select
    name: "Distance Mode"
    options: ["short", "medium", "long"]
    initial_option: "long"
    optimistic: true
    restore_value: true
    icon: "mdi:tape-measure"
    entity_category: config
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("config", "Distance mode changed to: %s", x.c_str());
            int m = 2;
            if (x == "short") m = 0; else if (x == "medium") m = 1;
            id(pref_distance_mode) = m;
        - script.execute: schedule_apply_runtime_prefs

  - platform: template
    id: power_mode_select
    name: "Power Mode"
    options: ["Performance", "Balanced", "Power Save"]
    initial_option: "Balanced"
    optimistic: true
    restore_value: true
    icon: "mdi:battery"
    entity_category: config
    on_value:
      then:
        - script.execute: apply_power_mode

##########################################################################################
# SCRIPTS — velocity & prefs
##########################################################################################
script:
  - id: calculate_velocity
    mode: single
    then:
      - lambda: |-
          const float d = id(distance_sensor).state;
          const unsigned long now = millis();

          if (!isnan(d) && id(last_measurement_time) > 0) {
            const unsigned long dt = now - id(last_measurement_time);
            if (dt > 50) {
              const float dd = d - id(last_distance);
              float raw_v = (dd / (float)dt) * 1000.0f;  // mm/s
              if (fabsf(raw_v) > 5000.0f) raw_v = (raw_v > 0.0f ? 5000.0f : -5000.0f);

              // Simple recursive filter
              const float meas_err = 50.0f;
              const float k = id(kalman_error_estimate) / (id(kalman_error_estimate) + meas_err);
              id(kalman_estimate) = id(kalman_estimate) + k * (raw_v - id(kalman_estimate));
              id(kalman_error_estimate) = (1.0f - k) * id(kalman_error_estimate);

              id(velocity_sensor_raw).publish_state(raw_v);
              id(velocity_sensor).publish_state(id(kalman_estimate));

              static float last_v = 0.0f;
              static unsigned long last_v_t = 0;
              if (last_v_t > 0) {
                const unsigned long dv_t = now - last_v_t;
                if (dv_t > 100) {
                  const float a = ((id(kalman_estimate) - last_v) / (float)dv_t) * 1000.0f;
                  id(acceleration_sensor).publish_state(a);
                  last_v = id(kalman_estimate);
                  last_v_t = now;
                }
              } else {
                last_v = id(kalman_estimate);
                last_v_t = now;
                id(acceleration_sensor).publish_state(0.0f);
              }
            }
          }

          id(last_distance) = d;
          id(last_measurement_time) = now;

  - id: apply_power_mode
    mode: single
    then:
      - lambda: |-
          std::string mode = id(power_mode_select).state;
          ESP_LOGI("config", "Applying power mode: %s", mode.c_str());
          if (mode == "Performance")      id(tof_sensor).set_update_interval(50);
          else if (mode == "Balanced")    id(tof_sensor).set_update_interval(100);
          else                             id(tof_sensor).set_update_interval(250);

  - id: schedule_apply_runtime_prefs
    mode: restart
    then:
      - logger.log: "Saving preferences… device will reboot in 2 seconds to apply."
      - delay: 2s
      - switch.turn_on: restart_switch

##########################################################################################
# CONTROL SURFACES — restart + test buttons
##########################################################################################
switch:
  - platform: restart
    id: restart_switch
    name: "Restart Device"
    entity_category: diagnostic

  - platform: template
    id: sensor_enable
    name: "Sensor Enable"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: "mdi:power"
    entity_category: config
    turn_on_action:  { - logger.log: "Sensor enable (placeholder — add driver hook if needed)" }
    turn_off_action: { - logger.log: "Sensor disable (placeholder — add driver hook if needed)" }

button:
  - platform: template
    id: calibrate_sensor
    name: "Calibrate Sensor"
    entity_category: config
    icon: "mdi:tune"
    on_press:
      - logger.log: "Calibration: reset counters & sample"
      - lambda: |-
          id(measurement_count) = 0;
          id(error_count) = 0;
          id(last_distance) = 0.0f;
          id(last_measurement_time) = 0;
          id(kalman_estimate) = 0.0f;
          id(kalman_error_estimate) = 1.0f;
      - repeat: { count: 10, then: [ delay: 100ms ] }

  - platform: template
    name: "Reset Zone Thresholds"
    entity_category: config
    icon: "mdi:restore"
    on_press:
      - number.set: { id: zone1_threshold_number, value: 1000 }
      - number.set: { id: zone2_threshold_number, value: 2000 }
      - number.set: { id: zone3_threshold_number, value: 3000 }
      - logger.log: "Zone thresholds reset to defaults"

  - platform: template
    name: "Clear Statistics"
    entity_category: diagnostic
    icon: "mdi:delete"
    on_press:
      - lambda: |-
          id(measurement_count) = 0;
          id(error_count) = 0;
          ESP_LOGI("button", "Statistics cleared");

##########################################################################################
# TIME + PERIODIC TASKS
##########################################################################################
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time_sync: { then: [ logger.log: "Time synchronized with Home Assistant" ] }

  - platform: sntp
    id: sntp_time
    servers: [pool.ntp.org, time.google.com]
    timezone: !secret timezone   # e.g., America/New_York

interval:
  - interval: 30s
    then:
      - if:
          condition: { mqtt.connected: {} }
          then:
            - mqtt.publish:
                topic: esp32s3-tof/heartbeat
                payload: !lambda 'return to_string(millis());'

  - interval: 60s
    then:
      - lambda: |-
          ESP_LOGD("stats", "Total measurements: %lu", id(measurement_count));

  - interval: 5min
    then:
      - component.update: free_heap
      - if:
          condition:
            lambda: 'return id(free_heap).state < 20.0f;'
          then:
            - logger.log:
                level: WARN
                format: "Low memory warning: %.1f kB free"
                args: ['id(free_heap).state']
