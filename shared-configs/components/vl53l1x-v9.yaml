# ——— ESP32-S3 + VL53L1X (Averyy) — Option B, ESPHome 2025.7.5-validated ———

substitutions:
  # sda_pin_i2c: GPIO8
  # scl_pin_i2c: GPIO9
  xshut_gpio: GPIO9  # reserved (not used here)

external_components:
  - source: github://Averyy/esphome-custom-components
    components: [vl53l1x]
    refresh: 1d

mqtt:
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  username: !secret mqtt_username
  password: !secret mqtt_password
  discovery: true
  discovery_prefix: homeassistant
  birth_message: { topic: esp32s3-tof/status, payload: online }
  will_message:  { topic: esp32s3-tof/status, payload: offline }
  on_message:
    - topic: esp32s3-tof/control/calibrate
      then:
        - button.press: calibrate_sensor
    - topic: esp32s3-tof/control/restart
      then:
        - switch.turn_on: restart_switch
    - topic: esp32s3-tof/control/set_roi
      then:
        - lambda: |-
            ESP_LOGD("mqtt", "ROI command received: %s", x.c_str());

api:
  services:
    - service: set_roi_config
      variables: { x_spads: int, y_spads: int, center: int }
      then:
        - lambda: |-
            ESP_LOGD("api", "Setting ROI: X=%d, Y=%d, Center=%d", x_spads, y_spads, center);
            id(roi_x_spads) = x_spads;
            id(roi_y_spads) = y_spads;
            id(roi_center_index) = center;
    - service: advanced_calibration
      variables: { offset: int, crosstalk: int }
      then:
        - lambda: |-
            ESP_LOGD("api", "Advanced calibration: offset=%d, crosstalk=%d", offset, crosstalk);
            // Placeholder only; needs driver hooks to apply.

i2c:
  - id: bus_a
    sda: ${sda_pin_i2c}
    scl: ${scl_pin_i2c}
    frequency: 400kHz
    scan: true

globals:
  - { id: last_distance,           type: float,          restore_value: no,  initial_value: '0.0' }
  - { id: last_measurement_time,   type: unsigned long,  restore_value: no,  initial_value: '0'   }
  - { id: kalman_estimate,         type: float,          restore_value: no,  initial_value: '0.0' }
  - { id: kalman_error_estimate,   type: float,          restore_value: no,  initial_value: '1.0' }
  - { id: zone1_threshold,         type: float,          restore_value: yes, initial_value: '1000.0' }
  - { id: zone2_threshold,         type: float,          restore_value: yes, initial_value: '2000.0' }
  - { id: zone3_threshold,         type: float,          restore_value: yes, initial_value: '3000.0' }
  - { id: roi_x_spads,             type: int,            restore_value: yes, initial_value: '16'  }
  - { id: roi_y_spads,             type: int,            restore_value: yes, initial_value: '16'  }
  - { id: roi_center_index,        type: int,            restore_value: yes, initial_value: '199' }
  - { id: measurement_count,       type: unsigned long,  restore_value: yes, initial_value: '0'   }
  - { id: error_count,             type: unsigned long,  restore_value: yes, initial_value: '0'   }
  - { id: pref_distance_mode,      type: int,            restore_value: yes, initial_value: '2'   } # 0/1/2
  - { id: pref_timing_budget_ms,   type: int,            restore_value: yes, initial_value: '50'  }

# Required top-level custom component
vl53l1x:
  id: tof_sensor

sensor:
  - platform: vl53l1x
    i2c_id: bus_a
    address: 0x32            # change to 0x29 if that's your module
    update_interval: 100ms   # runtime-adjustable via Power Mode script

    distance:
      id: distance_sensor
      name: "Distance"
      unit_of_measurement: "mm"
      accuracy_decimals: 0
      device_class: distance
      state_class: measurement
      filters:
        - median: { window_size: 5, send_every: 1 }
        - delta: 5.0
        - clamp: { min_value: 50, max_value: 4000, ignore_out_of_range: false }
      on_value:
        then:
          - script.execute: calculate_velocity
          - lambda: |-
              const float d = id(distance_sensor).state;
              const bool valid = (!isnan(d) && d > 50.0f);
              const float z1 = id(zone1_threshold);
              const float z2 = id(zone2_threshold);
              const float z3 = id(zone3_threshold);

              const bool obj  = valid && (d <= z3);
              const bool in1  = valid && (d <= z1);
              const bool in2  = valid && (d > z1 && d <= z2);
              const bool in3  = valid && (d > z2 && d <= z3);

              id(object_detected).publish_state(obj);
              id(zone1_detected).publish_state(in1);
              id(zone2_detected).publish_state(in2);
              id(zone3_detected).publish_state(in3);

              if (id(velocity_sensor).has_state()) {
                const float v = id(velocity_sensor).state;
                id(moving_towards).publish_state(v < -50.0f);
                id(moving_away).publish_state(v > 50.0f);
                id(motion_detected).publish_state(fabsf(v) > 50.0f);
              }

              if (in1)        id(active_zone).publish_state("Zone 1 (Close)");
              else if (in2)   id(active_zone).publish_state("Zone 2 (Medium)");
              else if (in3)   id(active_zone).publish_state("Zone 3 (Far)");
              else if (obj)   id(active_zone).publish_state("Beyond Zone 3");
              else            id(active_zone).publish_state("No Object");

              id(measurement_count) += 1;

  - platform: template
    id: velocity_sensor_raw
    name: "Velocity Raw"
    internal: true
    unit_of_measurement: "mm/s"
    accuracy_decimals: 1
    update_interval: never

  - platform: template
    id: velocity_sensor
    name: "Velocity"
    unit_of_measurement: "mm/s"
    accuracy_decimals: 1
    state_class: measurement
    icon: "mdi:speedometer"
    update_interval: never
    filters:
      - sliding_window_moving_average: { window_size: 5, send_every: 1 }
      - lambda: |-
          if (fabsf(x) < 10.0f) return 0.0f;
          return x;

  - platform: template
    id: acceleration_sensor
    name: "Acceleration"
    unit_of_measurement: "mm/s²"
    accuracy_decimals: 0
    icon: "mdi:axis-arrow"
    update_interval: never

  - platform: template
    id: effective_spad_count
    name: "Effective SPAD Count"
    accuracy_decimals: 0
    entity_category: diagnostic
    icon: "mdi:grid"
    update_interval: 10s
    lambda: |-
      return id(roi_x_spads) * id(roi_y_spads);

  - platform: template
    id: measurement_rate
    name: "Measurement Rate"
    unit_of_measurement: "Hz"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: "mdi:timer"
    update_interval: 5s
    lambda: |-
      static unsigned long last_count = 0, last_time = 0;
      const unsigned long now = millis();
      const unsigned long dt  = now - last_time;
      if (dt > 0) {
        const float rate = (id(measurement_count) - last_count) * 1000.0f / (float)dt;
        last_count = id(measurement_count);
        last_time  = now;
        return rate;
      }
      return 0;

  - platform: template
    id: error_rate
    name: "Error Rate"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: "mdi:alert-circle"
    update_interval: 30s
    lambda: |-
      if (id(measurement_count) > 0) {
        return (id(error_count) * 100.0f) / (float)id(measurement_count);
      }
      return 0;

  - platform: template
    id: free_heap
    name: "Free Memory"
    unit_of_measurement: "kB"
    entity_category: diagnostic
    icon: "mdi:memory"
    update_interval: 30s
    lambda: |-
      return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024.0f;

number:
  - platform: template
    id: zone1_threshold_number
    name: "Zone 1 Threshold"
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 1000
    restore_value: true
    icon: "mdi:numeric-1-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone1_threshold, value: !lambda 'return x;' }
        - lambda: |-
            if (x >= id(zone2_threshold)) {
              const float nz2 = x + 50.0f;
              id(zone2_threshold) = nz2;
              id(zone2_threshold_number).publish_state(nz2);
            }

  - platform: template
    id: zone2_threshold_number
    name: "Zone 2 Threshold"
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 2000
    restore_value: true
    icon: "mdi:numeric-2-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone2_threshold, value: !lambda 'return x;' }
        - lambda: |-
            if (x <= id(zone1_threshold)) {
              const float nz1 = x - 50.0f;
              id(zone1_threshold) = nz1;
              id(zone1_threshold_number).publish_state(nz1);
            }
            if (x >= id(zone3_threshold)) {
              const float nz3 = x + 50.0f;
              id(zone3_threshold) = nz3;
              id(zone3_threshold_number).publish_state(nz3);
            }

  - platform: template
    id: zone3_threshold_number
    name: "Zone 3 Threshold"
    optimistic: true
    min_value: 50
    max_value: 4000
    step: 50
    unit_of_measurement: "mm"
    initial_value: 3000
    restore_value: true
    icon: "mdi:numeric-3-box"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: zone3_threshold, value: !lambda 'return x;' }
        - lambda: |-
            if (x <= id(zone2_threshold)) {
              const float nz2 = x - 50.0f;
              id(zone2_threshold) = nz2;
              id(zone2_threshold_number).publish_state(nz2);
            }

  - platform: template
    id: timing_budget_number
    name: "Timing Budget (ms)"
    optimistic: true
    min_value: 20
    max_value: 500
    step: 10
    unit_of_measurement: "ms"
    initial_value: 50
    restore_value: true
    icon: "mdi:timer-settings"
    entity_category: config
    on_value:
      then:
        - globals.set: { id: pref_timing_budget_ms, value: !lambda 'return (int)x;' }
        - script.execute: schedule_apply_runtime_prefs

binary_sensor:
  - { platform: template, id: object_detected, name: "Object Detected", device_class: occupancy, icon: "mdi:target" }
  - { platform: template, id: zone1_detected, name: "Zone 1 Detected", device_class: occupancy, icon: "mdi:numeric-1-circle" }
  - { platform: template, id: zone2_detected, name: "Zone 2 Detected", device_class: occupancy, icon: "mdi:numeric-2-circle" }
  - { platform: template, id: zone3_detected, name: "Zone 3 Detected", device_class: occupancy, icon: "mdi:numeric-3-circle" }
  - { platform: template, id: moving_towards, name: "Moving Towards", device_class: moving, icon: "mdi:arrow-down-bold" }
  - { platform: template, id: moving_away, name: "Moving Away", device_class: moving, icon: "mdi:arrow-up-bold" }
  - { platform: template, id: motion_detected, name: "Motion Detected", device_class: motion, icon: "mdi:motion-sensor" }
  - platform: template
    id: sensor_problem
    name: "Sensor Problem"
    device_class: problem
    entity_category: diagnostic
    icon: "mdi:alert"
    lambda: |-
      if (id(error_rate).has_state() && id(error_rate).state >= 10.0f) return true;
      return false;

text_sensor:
  - { platform: template, id: active_zone,     name: "Active Zone",     icon: "mdi:map-marker-radius" }
  - { platform: template, id: movement_status, name: "Movement Status", icon: "mdi:motion" }
  - platform: template
    id: distance_mode_display
    name: "Current Distance Mode"
    icon: "mdi:ruler"
    entity_category: diagnostic
    lambda: |-
      switch (id(pref_distance_mode)) {
        case 0: return {"short"};
        case 1: return {"medium"};
        default: return {"long"};
      }
  - platform: template
    id: roi_config_display
    name: "ROI Configuration"
    icon: "mdi:grid"
    entity_category: diagnostic
    lambda: |-
      char buf[50];
      sprintf(buf, "%dx%d SPADs, Center: %d", id(roi_x_spads), id(roi_y_spads), id(roi_center_index));
      return {buf};
  - platform: template
    id: system_status
    name: "System Status"
    icon: "mdi:information"
    entity_category: diagnostic
    update_interval: 10s
    lambda: |-
      if (id(sensor_problem).state) return {"Sensor Error"};
      else if (id(error_rate).state > 5.0f) return {"Degraded Performance"};
      else return {"Operational"};

select:
  - platform: template
    id: distance_mode_select
    name: "Distance Mode"
    options: ["short", "medium", "long"]
    initial_option: "long"
    optimistic: true
    restore_value: true
    icon: "mdi:tape-measure"
    entity_category: config
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("config", "Distance mode changed to: %s", x.c_str());
            int m = 2; if (x == "short") m = 0; else if (x == "medium") m = 1;
            id(pref_distance_mode) = m;
        - script.execute: schedule_apply_runtime_prefs

  - platform: template
    id: power_mode_select
    name: "Power Mode"
    options: ["Performance", "Balanced", "Power Save"]
    initial_option: "Balanced"
    optimistic: true
    restore_value: true
    icon: "mdi:battery"
    entity_category: config
    on_value:
      then:
        - script.execute: apply_power_mode

script:
  - id: calculate_velocity
    mode: single
    then:
      - lambda: |-
          const float d = id(distance_sensor).state;
          const unsigned long now = millis();

          if (!isnan(d) && id(last_measurement_time) > 0) {
            const unsigned long dt = now - id(last_measurement_time);
            if (dt > 50) {
              const float dd = d - id(last_distance);
              float raw_v = (dd / (float)dt) * 1000.0f;
              if (fabsf(raw_v) > 5000.0f) raw_v = (raw_v > 0.0f ? 5000.0f : -5000.0f);

              const float meas_err = 50.0f;
              const float k = id(kalman_error_estimate) / (id(kalman_error_estimate) + meas_err);
              id(kalman_estimate) = id(kalman_estimate) + k * (raw_v - id(kalman_estimate));
              id(kalman_error_estimate) = (1.0f - k) * id(kalman_error_estimate);

              id(velocity_sensor_raw).publish_state(raw_v);
              id(velocity_sensor).publish_state(id(kalman_estimate));

              static float last_v = 0.0f;
              static unsigned long last_v_t = 0;
              if (last_v_t > 0) {
                const unsigned long dv_t = now - last_v_t;
                if (dv_t > 100) {
                  const float a = ((id(kalman_estimate) - last_v) / (float)dv_t) * 1000.0f;
                  id(acceleration_sensor).publish_state(a);
                  last_v = id(kalman_estimate);
                  last_v_t = now;
                }
              } else {
                last_v = id(kalman_estimate);
                last_v_t = now;
                id(acceleration_sensor).publish_state(0.0f);
              }
            }
          }
          id(last_distance) = d;
          id(last_measurement_time) = now;

  - id: apply_power_mode
    mode: single
    then:
      - lambda: |-
          const std::string mode = id(power_mode_select).state;
          ESP_LOGI("config", "Applying power mode: %s", mode.c_str());
          if (mode == "Performance")       id(tof_sensor).set_update_interval(50);
          else if (mode == "Balanced")     id(tof_sensor).set_update_interval(100);
          else                              id(tof_sensor).set_update_interval(250);

  - id: schedule_apply_runtime_prefs
    mode: restart
    then:
      - logger.log: "Saving preferences… device will reboot in 2 seconds to apply."
      - delay: 2s
      - switch.turn_on: restart_switch

switch:
  - platform: restart
    id: restart_switch
    name: "Restart Device"
    entity_category: diagnostic

  - platform: template
    id: sensor_enable
    name: "Sensor Enable"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: "mdi:power"
    entity_category: config
    turn_on_action:
      - logger.log: "Sensor enable (placeholder — add driver hook if needed)"
    turn_off_action:
      - logger.log: "Sensor disable (placeholder — add driver hook if needed)"

time:
  - platform: homeassistant
    id: homeassistant_time
    on_time_sync:
      then:
        - logger.log: "Time synchronized with Home Assistant"

  - platform: sntp
    id: sntp_time
    servers: [pool.ntp.org, time.google.com]
    timezone: !secret timezone  # e.g., America/New_York

interval:
  - interval: 30s
    then:
      - if:
          condition:
            mqtt.connected:
          then:
            - mqtt.publish:
                topic: esp32s3-tof/heartbeat
                payload: !lambda 'return to_string(millis());'

  - interval: 60s
    then:
      - lambda: |-
          ESP_LOGD("stats", "Total measurements: %lu", id(measurement_count));

  - interval: 5min
    then:
      - component.update: free_heap
      - if:
          condition:
            lambda: 'return id(free_heap).state < 20.0f;'
          then:
            - logger.log:
                level: WARN
                format: "Low memory warning: %.1f kB free"
                args: ['id(free_heap).state']
